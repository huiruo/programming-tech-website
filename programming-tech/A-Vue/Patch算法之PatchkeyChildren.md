---
title: Patch算法之PatchkeyChildren
sidebar_position: -1
---

## 开头
patchKeyedChildren是patch算法中较为复杂的一段，首先patchKeyedChildren是在子列表对比并且有key的情况会进入，并且逻辑大致分为5步
### 第一步,从前向后遍历
这一步是从节点组头部向尾部遍历，如果遍历过程中遇到相似节点，就进行patch对比，否则就退出遍历，并记录当前遍历的最新下标


### 第二步，从后向前遍历
从后向前遍历，如果遇到第一步记录的下标就停止，然后遍历过程中，如果遇到相似节点也是直接进行patch对比，如果不相同就是直接退出遍历，并且记录旧节点组和新节点组的尾指针

### 第三步，检查旧节点组
这一步就是检查旧节点组在上两步的遍历后是否遍历完，如果遍历完，那么新节点组没有遍历完的就都是新的dom，可以全部当作新增节点进行挂载处理

### 第四步，检查新节点组
如果上一步检查旧节点未遍历完，那么就检查新节点组是否遍历完，如果遍历完，那么旧的节点组剩余的节点说明都是要卸载的，因为都不需要了

### 第五步，未知序列

-   如果新旧节点组都未遍历完，说明存在未知序列，可能存在位移等情况，就需要进一步处理
-   首先创建一个数组，用于记录新旧节点的对应关系
```js
// toBePatched是新序列的节点数量 e2 - s2 + 1
const newIndexToOldIndexMap = new Array(toBePatched)
for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0
```
* 然后会遍历旧节点组，这里会用两个变量记录
let moved = false：位移标识，用于判断是否需要位移
let patched = 0：记录已执行patch的新节点数量，用于处理如果在更新时更新过的数量大于需要更新的节点数量，就卸载对应旧节点
