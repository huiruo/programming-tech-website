
信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。

有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。
```
这些信号是定义在 c 头文件 <csignal> 中。

SIGABRT	程序的异常终止，如调用 abort。
SIGFPE	错误的算术运算，比如除以零或导致溢出的操作。
SIGILL	检测非法指令。
SIGINT	程序终止(interrupt)信号。
SIGSEGV	非法访问内存。
SIGTERM	发送到程序的终止请求。
```

## signal() 函数
c 信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法：
```c
void (*signal (int sig, void (*func)(int)))(int); 

// 以下语法格式更容易理解：
// 第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。
signal(registered signal, signal handler)
```

使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 signal 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：
```c
#include <iostream>
#include <csignal>
#include <unistd.h>
 
using namespace std;
 
void signalHandler( int signum )
{
    cout << "Interrupt signal (" << signum << ") received.\n";
 
    // 清理并关闭
    // 终止程序  
 
   exit(signum);  
 
}
 
int main ()
{
    // 注册信号 SIGINT 和信号处理程序
    signal(SIGINT, signalHandler);  
 
    while(1){
       cout << "Going to sleep...." << endl;
       sleep(1);
    }
 
    return 0;
}
/*
Going to sleep....
Going to sleep....
Going to sleep....
*/

// 现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：
/*
Going to sleep....
Going to sleep....
Going to sleep....
Interrupt signal (2) received.
*/
```

## raise() 函数
使用函数 raise() 生成信号，该函数带有一个整数信号编号作为参数，语法如下：
```c
int raise (signal sig);
```
sig 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：
```c
#include <iostream>
#include <csignal>
#include <unistd.h>
 
using namespace std;
 
void signalHandler( int signum )
{
    cout << "Interrupt signal (" << signum << ") received.\n";
 
    // 清理并关闭
    // 终止程序 
 
   exit(signum);  
 
}
 
int main ()
{
    int i = 0;
    // 注册信号 SIGINT 和信号处理程序
    signal(SIGINT, signalHandler);  
 
    while(++i){
       cout << "Going to sleep...." << endl;
       if( i == 3 ){
          raise( SIGINT);
       }
       sleep(1);
    }
 
    return 0;
}
/*
Going to sleep....
Going to sleep....
Going to sleep....
Interrupt signal (2) received.
*/
```
