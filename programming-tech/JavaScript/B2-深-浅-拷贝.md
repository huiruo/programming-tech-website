
```js
const testArr =  [
  {
    'imgUrl': [
        'https://cn-beijing.aliyuncs.com/tp-uat/pmhmh1kt24g0000000.png'
    ],
    'areaShow': true,
    'levelShow': true,
    'linkType': 'page',
    'page': ''
  },
  {
    'imgUrl': [
        'https://cn-beijing.aliyuncs.com/tp-uat/pmhmh1kt24g0000000.png'
    ],
    'areaShow': true,
    'levelShow': true,
    'linkType': 'page',
    'page': ''
  },
]

// 方法1: 当遇到一个数组或对象时，就递归调用 deepCopy 函数，直到拷贝完成。注意，在拷贝对象属性时，需要使用 hasOwnProperty 方法来判断是否是对象自身的属性，以避免拷贝原型链上的属性。
const deepCopy = (obj) => {
  let newObj = Array.isArray(obj) ? [] : {};
  
  if (obj && typeof obj === "object") {
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        newObj[key] = deepCopy(obj[key]);
      }
    }
  } else {
    newObj = obj;
  }

  return newObj;
};

// 方法2: 在处理循环引用的对象时会出现问题。此外，这种方法也不够高效，因为需要将对象转换为字符串再解析为对象，如果对象比较大的话，会占用较多的内存和处理时间
const testArrCopy = JSON.parse(JSON.stringify(testArr));

// 方法3: 做浅拷贝
const testArrCopy = [...testArr];
```