<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
</head>
<style>
  .btn {
    margin-right: 10px;
    border: 0px;
    color: white;
    background-color: rgb(99, 99, 242);
  }
</style>

<body>
  <script src="./react.development18.js"></script>
  <script src="./react-dom.development18.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <div id="root"></div>
  <script type="text/babel">
    function Test() {
      console.log('test-render')
      const [data, setData] = React.useState('改变我')
      const [showDiv, setShowDiv] = React.useState(false)
      const [obj, setObj] = React.useState({ test: 1, test2: 2 })
      const [count, setCount] = React.useState(1)

      React.useEffect(() => {
        console.log('Test-super=副作用-useEffect-->运行');
        return () => {
          console.log('useEffect销毁时触发的回调');
        };
      }, [])

      React.useEffect(() => {
        console.log('Test-super=useEffect不依赖-模拟组件更新->运行');
      })

      React.useLayoutEffect(() => {
        console.log('=副作用-useLayoutEffect-->运行');
      }, [])

      const onClickText = () => {
        console.log('=useState=onClick=例5-没有导致state的值发生变化的setState是否会导致重渲染?',);
        setData('努力')
      }

      const changeSubData = () => {
        console.log('changeSubData')
        // obj.test1 = 5
        setObj({ ...obj, test1: 3 })
      }

      const onClickText2 = () => {
        console.log('=useState=onClick:', data);
        setShowDiv(true)
      }

      const onClickToChangeSub2 = () => {
        setCount(count + 1)
      }

      console.log('Test-render->运行');

      return (
        <div id='div1' className='c1'>
          <button onClick={onClickText} className="btn">Hello world,Click me</button>
          <button onClick={changeSubData} className="btn">changeSubData</button>
          <button onClick={onClickToChangeSub2} className="btn">onClickToChangeSub2</button>
          <span>{data}</span>
          {showDiv && <div>被你发现了</div>}
          <div id='div2' className='c2'>
            <p>测试子节点</p>
          </div>
          {/* changeSubData这将触发更新
            <Sub obj={obj} changeSubData={changeSubData} />

            <Sub2 count={count} />
          */}
          <Sub obj={obj} />
          <Sub2Memo count={count} />

        </div>
      )
    }

    function Sub(props) {
      const { obj } = props

      React.useEffect(() => {
        console.log('Sub=副作用-useEffect-->运行');
      }, [])

      React.useEffect(() => {
        console.log('Sub=useEffect不依赖-模拟组件更新-->运行');
      })

      console.log('sub-render->运行', obj);

      return (
        <div id='div1' className='c1'>
          sub component
          test1: {obj.test1 || '-'}
          test2: {obj.test2 || '-'}
        </div>
      )
    }

    function Sub2(props) {
      const { count = 0 } = props

      React.useEffect(() => {
        console.log('Sub2=副作用-useEffect-->运行');
      }, [])

      React.useEffect(() => {
        console.log('Sub2=useEffect不依赖-模拟组件更新-->运行');
      })

      console.log('sub2=render->运行');
      return (
        <div id='div1' className='c1'>
          sub2 test1: {count}
        </div>
      )
    }

    function isEqual(prevProps, nextProps) {
      if (prevProps.count === nextProps.count) {
        // isEqual 返回 true 时，不会触发 render
        return true
      } else {
        // false: go to render
        return false
      }
    }

    const Sub2Memo = React.memo(Sub2, isEqual)

    const root = ReactDOM.createRoot(document.getElementById('root'))
    root.render(<Test />);
  </script>
</body>

</html>