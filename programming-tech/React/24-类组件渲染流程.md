
## 前言
* 组件的定义方式
  * 函数组件(Functional Component)
  * 类组件(Class Component)
* 件内部是否有状态
  * 无状态组件(Stateless Component )和有状态组件(Stateful Component)
* 组件的不同职责
  * 展示型组件(Presentational Component 只展示，业务逻辑较少)
  * 容器型组件(Container Component 有着复杂的业务逻辑)

## 类组件定义
* 类组件需要继承自 React.Component 或 React.PureComponent
* 类组件必须实现render函数
* 组件的名称是大写字符开头,函数组件要大写
```js
<script type="text/babel">
  class LikeButton extends React.Component {
    constructor(props) {
      super(props);
      this.state = { liked: false };
    }

    render() {
      console.log('render start')
      if (this.state.liked) {
        return (
          <div onClick={() => this.setState({ liked: !this.state.liked })}>click me again</div>);
      }
      return (
        <div>
          <button onClick={() => this.setState({ liked: !this.state.liked })}>
            Like1
          </button>
          <p>这是兄弟节点</p>
        </div>
      );
    }
  }
  const container = document.getElementById('root');
  const astTree = React.createElement(LikeButton)
  console.log('createElement 转化后ast树的结构:', astTree)
  // debugger
  const root = ReactDOM.createRoot(container);
  root.render(astTree);
</script>
```

### 周期
* componentDidMount函数:组件已经挂载到DOM上时
* componentDidUpdate函数:组件已经发生了更新时
* componentWillUnmount函数:组件即将被移除时

参考：[useEffect](./useEffect)


## 探究类组件的构建fiber树
```
测试实例：例8-测试函数组件-18.html
```

### beginWork进入
如下例函数renderRootSync debugger
```js
  function renderRootSync(root, lanes) {
    var prevExecutionContext = executionContext;
    executionContext |= RenderContext;
    var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
    // and prepare a fresh one. Otherwise we'll continue where we left off.

    if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
      {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;

          if (memoizedUpdaters.size > 0) {
            restorePendingUpdaters(root, workInProgressRootRenderLanes);
            memoizedUpdaters.clear();
          } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.
          // If we bailout on this work, we'll move them back (like above).
          // It's important to move them now in case the work spawns more work at the same priority with different updaters.
          // That way we can keep the current update and future updates separate.


          movePendingFibersToMemoized(root, lanes);
        }

      }


      // console.log('workInProgress', workInProgress, root)
      debugger
      console.log('render调用 prepareFreshStack前', workInProgress)
      workInProgressTransitions = getTransitionsForLanes();
      prepareFreshStack(root, lanes);
      console.log('render调用 prepareFreshStack后', workInProgress)
    }

    {
      markRenderStarted(lanes);
    }

    do {
      try {
        console.log('%c=render阶段准备:', 'color:red', 'renderRootSync()调用workLoopSync()-root:', { root });
        debugger
        workLoopSync();
        break;
      } catch (thrownValue) {
        handleError(root, thrownValue);
      }
    } while (true);
    // 省略
  }
```
```js
switch (workInProgress.tag) {
      case ClassComponent:
        {
          var _Component = workInProgress.type;
          var _unresolvedProps = workInProgress.pendingProps;

          var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
          console.log('%c=beginWork()=end 5 updateClassComponent', 'color:magenta')
          return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);
        }
}
```

`_Component`
```js
function LikeButton(props) {
    _classCallCheck(this, LikeButton);

    var _this = _possibleConstructorReturn(this, (LikeButton.__proto__ || Object.getPrototypeOf(LikeButton)).call(this, props));

    _this.state = { liked: false };
    return _this;
  }
```

```js
function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
    // 省略
    if (instance === null) {
      if (current !== null) {
        // A class component without an instance only mounts if it suspended
        // inside a non-concurrent tree, in an inconsistent state. We want to
        // treat it like a new mount, even though an empty version of it already
        // committed. Disconnect the alternate pointers.
        current.alternate = null;
        workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

        workInProgress.flags |= Placement;
      } // In the initial pass we might need to construct the instance.


      constructClassInstance(workInProgress, Component, nextProps);
      mountClassInstance(workInProgress, Component, nextProps, renderLanes);
      shouldUpdate = true;
    } else if (current === null) {
      // In a resume, we'll already have an instance we can reuse.
      shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);
    } else {
      shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);
    }

    var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);

    {
      var inst = workInProgress.stateNode;

      if (shouldUpdate && inst.props !== nextProps) {
        if (!didWarnAboutReassigningProps) {
          error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');
        }

        didWarnAboutReassigningProps = true;
      }
    }

    return nextUnitOfWork;
  }
```

### 最后在这个函数调用函数组件的render函数->instance.render
```js
function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {

  // 省略
  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
    // If we captured an error, but getDerivedStateFromError is not defined,
    // unmount all the children. componentDidCatch will schedule an update to
    // re-render a fallback. This is temporary until we migrate everyone to
    // the new API.
    // TODO: Warn in a future release.
    nextChildren = null;

    {
      stopProfilerTimerIfRunning();
    }
  } else {
    {
      markComponentRenderStarted(workInProgress);
    }

    {
      setIsRendering(true);
      nextChildren = instance.render();

      if (workInProgress.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(true);

        try {
          instance.render();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }

      setIsRendering(false);
    }

    {
      markComponentRenderStopped();
    }
  }
  // 省略
}
```

类组件也在这里赋值memoizedState
```js
workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.
```

调用render
```js
nextChildren = instance.render();
```
### 也就是类组件的render函数
```js
render() {
  console.log('render start')
  if (this.state.liked) {
    return (
      <div onClick={() => this.setState({ liked: !this.state.liked })}>click me again</div>);
  }
  return (
    <div>
      <button onClick={() => this.setState({ liked: !this.state.liked })}>
        Like1
      </button>
      <p>这是兄弟节点</p>
    </div>
  );
}
```

### 重点：return调用的是createElement,可见和函数组件是一样的也是babel编译后的createElement
react.development18.js
```js
function createElement(type, config, children) {}
```

render函数的return debugger 进入的是createElementWithValidation,创建fiber节点
```js
  function createElementWithValidation(type, props, children) {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendumForProps(props);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      {
        error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
      }
    }

    var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    if (type === REACT_FRAGMENT_TYPE) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
```

## 最后调用reconcileChildren
```js
function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
  // 省略
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
}
```

```js
 function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
    if (current === null) {
      // If this is a fresh new component that hasn't been rendered yet, we
      // won't update its child set by applying minimal side-effects. Instead,
      // we will add them all to the child before it gets rendered. That means
      // we can optimize this reconciliation pass by not tracking side-effects.
      console.log('%c=reconcileChildren mount', 'blueviolet');
      // 对于 mount 的组件
      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
      console.log('%c=reconcileChildren mount 返回值workInProgress.child', 'blueviolet', workInProgress.child);
    } else {
      // 省略
    }
  }
```