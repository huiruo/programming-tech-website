---
title: 浏览器正常运行流程-静态-同步
sidebar_position: 1
---


## 总览
![](../assets/img-build/webpack打包后浏览器执行初始化流程.png)

## IIFE:立即执行函数
里面全都是立即执行函数
```js
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({
   console.log('IIFE:立即执行函数')
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
      console.log('__webpack_require__1')
/******/ 			return cachedModule.exports;
      /******/
    }
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
      /******/
    };
/******/

    /******/ 		// Execute the module function,保证模块中的 this 指向永远指向当前的模块
    console.log('__webpack_modules__[moduleId].call:执行模块方法', { __webpack_modules__, moduleId, exports: module.exports })

/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
    /******/

    console.log('__webpack_require__2', module)
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
    /******/
  }


/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
      console.log('__webpack_require__.e被调用')
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
        console.log('__webpack_require__.f被调用')
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
        /******/
      }, []));
      /******/
    };
    /******/
  })();

  /******/ 	// startup
  /******/ 	// Load entry module and return exports
  /******/ 	// This entry module can't be inlined because the eval devtool is used.
  console.log('调用：__webpack_require__')
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");

})()
```

### `__webpack_modules__`是一个对象
对象的 key 就是每个 js 模块的相对路径，value 就是一个函数（我们下面称之为模块函数）。

IIFE 末尾执行 会先 require 入口模块。即上面就是 ./src/index.js
```js
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
```

### `__webpack_require__()`就是来加载一个模块，并在最后返回模块 module.exports 变量
去 require 其他模块的函数主要是`__webpack_require__`
然后入口模块会在执行时 require 其他模块例如 lodash,以下为简化后的代码，从而不断的加载所依赖的模块，形成依赖树
```js
// 如下的模块函数中就引用了其他的文件 ./node_modules/lodash/lodash.js
/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nfunction component() {\r\n  const element = document.createElement('div');\r\n  const button = document.createElement('button');\r\n  const br = document.createElement('br');\r\n\r\n  button.innerHTML = 'Click me and look at the console!';\r\n  element.innerHTML = lodash__WEBPACK_IMPORTED_MODULE_0___default().join(['Hello', 'webpack'], ' ');\r\n  element.appendChild(br);\r\n  element.appendChild(button);\r\n\r\n  // Note that because a network request is involved, some indication\r\n  // of loading would need to be shown in a production-level site/app.\r\n  button.onclick = e => __webpack_require__.e(/*! import() | print */ \"print\").then(__webpack_require__.bind(__webpack_require__, /*! ./print */ \"./src/print.js\")).then(module => {\r\n    const print = module.default;\r\n\r\n    print();\r\n  });\r\n\r\n  return element;\r\n}\r\n\r\ndocument.body.appendChild(component());\r\n\n\n//# sourceURL=webpack://webpack-helloworld/./src/index.js?");

        /***/
      })

    /******/
  });
```


## webpack 是如何支持 ESM 的
可能大家已经发现，上面的写法是 ESM 的写法;对于模块化的一些方案的了解,Javascript 中的 CJS, AMD, UMD 和 ESM是什么？

就是为 '__webpack_exports__` 添加一个属性 __esModule，值为 true
```js
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
      console.log('__webpack_require__.r', exports)
/******/ 			if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /******/
      }
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    };
    /******/
  })();
```
`__webpack_require__.n`
```
__webpack_require__.n会判断module是否为es模块，当__esModule为 true 的时候，标识 module 为es 模块，默认返回module.default，否则返回module。

最后看 __webpack_require__.d，主要的工作就是将上面的 getter 函数绑定到 exports 中的属性 a 的 getter 上
```
```js
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
      /******/
    };
    /******/
  })();
```