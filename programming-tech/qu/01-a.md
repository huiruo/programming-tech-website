---
title: react-vue
sidebar_position: 1
---

## react
### vue和react的区别

### 1. react中有对状态管理做进一步封装吗
React Context API: React自身提供了一种状态管理的方式，称为Context API。你可以使用React.createContext来创建一个上下文对象，将状态存储在该上下文中，并使用Provider和Consumer组件来在组件层次结构中传递状态。尽管Context API可以用于简单的状态管理，但它不如Redux或Mobx那么强大。

### 2. react中在父组件中如何获取了组件的方法
1. 使用React.createRef()创建引用：
首先，在父组件中使用React.createRef()来创建一个引用对象，然后将该引用对象分配给子组件的ref属性。这样，你就可以在父组件中访问子组件的实例。
```js
class ParentComponent extends React.Component {
  constructor(props) {
    super(props);
    this.childRef = React.createRef();
  }

  // 通过引用访问子组件的方法
  someMethodInParent() {
    this.childRef.current.someMethodInChild();
  }

  render() {
    return <ChildComponent ref={this.childRef} />;
  }
}
```

2. hooks:
父组件：
```js
export function TemplateModal(props: TemplateModalProps) {
  const formRef: any = useRef()
	// 调用子组件的方法
  const handleCancel = () => {
    formRef.current.resetForm()
    onClose()
    cleanModalCache()
  }

  return (
		<AddForm ref={formRef} formValues={formValues} />
	)
}
```

```js
export function AddForm(props: AddFormPrps, ref: any) {
  const [form] = Form.useForm()

	// 暴露组件的方法
  useImperativeHandle(ref, () => ({
    submitForm: () => {
      const values = form.getFieldsValue()
      return values
    },
    resetForm: () => {
      form.resetFields()
    }
  }))

	return (
	      <Form
        form={form}
        name='template_form'
        layout='inline'
        onFinish={onFinish}
        initialValues={{ title: '', type: 0, tags: [] }}
      />
  )
}

const WrappedAddForm = forwardRef(AddForm)

export default WrappedAddForm
```

### 3.react函数组件和类组件处理重复演染有什么区别?
* shouldComponentUpdate return true 就会render
* isEqual 返回 true 时，不会触发 render

### 4.方法什么时候写在父组件中，什么时候写在子组件中?
决定将方法写在父组件还是子组件中取决于方法的用途以及数据的流动方式。以下是一些指导原则，可以帮助你决定应该在哪里编写方法：
1. 方法写在父组件中的情况：
  * 数据传递和状态提升：如果方法需要在多个子组件之间共享并且操作共享的数据（状态提升），通常将方法定义在最近共享状态的父组件中。这有助于保持数据的一致性和可维护性。
  * 跨组件通信：如果你需要在不直接嵌套的组件之间传递数据或触发操作，将方法定义在更高级别的父组件中，然后通过props将它们传递给相关子组件。
  * 处理全局状态：如果你使用状态管理工具（如Redux）来管理全局状态，通常会在顶层容器组件中定义方法，以便在整个应用程序中共享和操作全局状态。
2. 方法写在子组件中的情况：
  * 组件内部逻辑：如果方法的逻辑仅涉及到特定子组件内部的操作，将方法定义在子组件中，以保持组件的封装性和独立性。
  * 重用性：如果方法仅在一个子组件内部使用，并且不会在其他地方复用，将其定义在子组件内是有意义的。这可以使组件更加自包含，易于维护。
  * 事件处理：通常，处理与子组件直接相关的事件（例如按钮点击或表单提交）的方法应该位于子组件中。这有助于将逻辑封装在子组件内部，使其更具可读性。

### 5.react中组件传值
1. 使用props（属性）来在组件之间传递值。Props是一种将数据从父组件传递到子组件的机制
2. Context API：React的Context API允许你在整个组件树中共享数据，而不必手动将props一层一层传递。它特别适用于跨层级的数据共享
3. Redux
4. HOC（高阶组件）：高阶组件是一个接受一个组件并返回一个新组件的函数。你可以使用高阶组件来包装子组件，并将额外的功能或数据传递给子组件。

### 6.虚拟dom的理解
见doc

### 7.redux的工作流程
见doc

## vue

### 1.Vue2和vue3的tree shaking的区别
Tree Shaking 是一种用于优化前端 JavaScript 应用程序大小的技术，它可以通过删除未使用的代码来减小最终的打包文件大小。以下是 Vue.js 2 和 Vue.js 3 在 Tree Shaking 方面的主要区别：

1. 模块系统的不同:
  * Vue.js 2 使用的是 CommonJS 模块系统。CommonJS 模块的导入和导出方式不够静态，这意味着 Webpack 在尝试进行 Tree Shaking 时可能会遇到一些困难。因此，Vue.js 2 的Tree Shaking 支持并不是特别好。
  * Vue.js 3 使用的是 ES 模块系统，这是一种更适合静态分析的模块系统。这使得 Vue.js 3 更容易进行 Tree Shaking，因为工具可以更容易地分析和确定哪些代码未被使用。

2. Composition API:
  * Vue.js 3 引入了 Composition API，它使得代码更容易组织和重用。这有助于提高 Tree Shaking 的效果，因为你可以更精确地控制哪些组合函数和逻辑被包含在最终的捆绑文件中。
  懒加载:

  * Vue.js 3 提供了更好的支持懒加载（Lazy Loading）组件的机制，这可以进一步提高 Tree Shaking 的效果。你可以延迟加载只有在需要时才加载的组件，而不是将所有组件一次性打包到主文件中。

### 2.vue3 怎么实现懒加载？
懒加载的好处：懒加载后，当用户首次访问某个路由时，相关组件会在那个时刻加载，而不会在应用程序启动时加载，从而提高初始加载速度。

配置路由：首先，你需要使用 Vue Router 配置你的路由。确保你已经安装了 Vue Router。
```js
import { createRouter, createWebHistory } from 'vue-router';

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/',
      component: () => import('./views/Home.vue') // 异步加载 Home 组件
    },
    {
      path: '/about',
      component: () => import('./views/About.vue') // 异步加载 About 组件
    },
    // 其他路由配置
  ]
});

export default router;
```

### 4.vue的双向数据绑定的原理
[vue的双向数据绑定的原理](../Vue/api-vBind单向-vModel原理)

### 4.vuex
未总结

### vue为什么data属性是一个函数而不是一个对象
1. 数据隔离：每个 Vue 组件实例需要维护自己的数据状态，如果 data 是一个对象，那么不同组件实例共享相同的数据对象，这可能导致状态污染和不可预测的行为。通过将 data 定义为一个函数，每个组件实例都会返回一个独立的数据对象，从而保持了数据的隔离。
2. 初始化数据：data 函数返回的数据对象会在组件实例化时被深度复制，以确保每个组件实例都有自己的初始数据副本。

> Vue 组件是可以复用的，如果多个组件实例都共享一个数据对象，那么在一个组件中修改数据可能会影响到其他组件，这是不合理的。通过将 data 定义为一个函数，你可以确保每个组件都有自己的数据副本，从而实现组件的复用性。

### 5.vue的生命周期有哪些，data里面的数据初始化是在哪个阶段
[vue的生命周期有哪些](../Vue/api-lifecycle-vue3-vue2区别)

表面上看
* 数据初始化通常发生在 created 钩子中。在这个阶段，组件实例已经创建，数据已经初始化，但模板编译和挂载阶段还未开始。你可以在 created 钩子中访问和操作组件的 data 数据。
* 在 Vue.js 3.x 中，对应的初始化数据的阶段也在 setup 函数中，通常在 onBeforeMount 钩子之前。

源码的阶段看:
[例子](https://github.com/huiruo/programming-tech-website/blob/main/programming-tech/Vue/vue3%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E4%BE%8B%E5%AD%90/00-vue3-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E8%B0%83%E8%AF%95.html)

在构建vnode前执行，
```bash
# 此时调用reactive--createReactiveObject创建一个代理对象并返回:方便以后触发track
start响应式=>setup() color:chartreuse

--1:组件挂载前 onBeforeMount-->

# 开始调用code-->vnode
=vnode-构建:start-->调用Ast生成的render函数
vnode-构建:b-->createBaseVNode返回值

# 递归调用patch构建之后
--2:组件挂载后 onMounted-->
```

### 6.vue的自定义指令用过没
在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性

通过 genDirectives 生成指令代码

在 patch 前，将指令的钩子提取到 cbs 中，在 patch 过程中调用对应的钩子

当执行 cbs 对应的钩子时，调用对应指令定义方法

vue 3 的自定义指令是通过 Vue 3 的插件系统来实现的，其源码原理涉及到 Vue 3 的编译器和运行时的协作。以下是自定义指令的源码原理概述：
1. 自定义指令的注册:
    * 开发者使用 app.directive 方法来注册自定义指令。这个方法将自定义指令的名称和一个包含钩子函数的对象作为参数。
2. 编译器:
    * 在模板编译阶段，编译器会识别和处理模板中的自定义指令。当编译器遇到使用自定义指令的元素，它会生成相应的渲染函数代码。
3. 渲染函数:
    * 生成的渲染函数代码包括指令的处理逻辑。这个逻辑负责在运行时应用指令到元素上。
4. 运行时:
    * 在组件实例化并挂载到 DOM 之后，Vue 3 运行时会执行渲染函数代码。当渲染函数执行时，它会检查元素是否有绑定了自定义指令，然后执行相应的钩子函数。
5. 钩子函数:
    * 自定义指令对象中的钩子函数（如 mounted、beforeUpdate、unmounted 等）会在合适的时机被调用，以实现自定义指令的具体行为。例如，mounted 钩子会在元素被挂载到 DOM 后执行，用于设置元素的初始状态。

场景：
1. 自定义输入验证：你可以创建自定义指令来验证用户的输入，例如，只允许输入特定格式的电话号码或电子邮件地址。 
2. 懒加载图片：创建一个自定义指令，以便在图片进入可视窗口时再加载它们，以提高性能。
3. 无限滚动：你可以创建一个自定义指令，当用户滚动到页面底部时，自动加载更多内容。

方法1:
```js
<template>
  <div>
    <input v-limit-length="11" v-model="inputValue" />
  </div>
</template>

<script>
export default {
  data() {
    return {
      inputValue: ''
    };
  },
  directives: {
    'limit-length': {
      // 自定义指令的定义
      mounted(el, binding) {
        const maxLength = binding.value || 11;

        el.addEventListener('input', function () {
          if (el.value.length > maxLength) {
            el.value = el.value.slice(0, maxLength); // 截断输入值
          }
        });
      }
    }
  }
};
</script>
```

方法1:
在`<script setup>`中，任何以 v 开头的驼峰式命名的变量都可以被用作一个自定义指令。在上面的例子中

```html
<script setup>
// 在模板中启用 v-focus
const vFocus = {
  mounted: (el) => el.focus()
}
</script>

<template>
  <input v-focus />
</template>
```

方法2:
```js
const app = Vue.createApp({});

app.directive('my-directive', {
  beforeMount(el, binding, vnode) {
    // 在元素挂载到 DOM 之前执行
    // el: 指令绑定的元素
    // binding: 包含指令的信息，如传递给指令的参数和修饰符
    // vnode: 虚拟节点
  },
  mounted(el, binding, vnode) {
    // 元素挂载到 DOM 之后执行
  },
  beforeUnmount(el, binding, vnode) {
    // 在元素销毁之前执行
  },
  unmounted(el, binding, vnode) {
    // 元素销毁之后执行
  }
});

<template>
  <div v-my-directive="directiveValue">Custom Directive Example</div>
</template>
```