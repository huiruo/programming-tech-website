---
title: others
sidebar_position: 1
---

### 讲一下 webpack 的 loader 和 plugin

### 讲一下 Babel 的原理，讲一下 AST 抽象语法树
### 讲一下你所知道的设计模式
### 讲一下 webpack 的打包流程
Webpack 的打包流程是将前端项目中的多个源文件（包括 JavaScript、CSS、HTML、图片等）打包成一个或多个输出文件的过程。Webpack 的打包流程可以分为以下主要步骤：

1. **入口点（Entry Point）**：Webpack 根据你的配置文件（通常是 `webpack.config.js`）中的入口点配置，确定打包的入口文件或入口模块。入口点是构建过程的起始位置。

2. **依赖解析（Dependency Resolution）**：Webpack 开始从入口点出发，递归解析所有的依赖模块。这包括 JavaScript 模块之间的 `import` 和 `require` 语句，以及其他资源文件（如 CSS、图片等）的依赖关系。

3. **加载器（Loaders）**：在依赖解析阶段，Webpack 使用加载器来转换不同类型的文件，将它们转换成适合打包的模块。加载器通常用于处理非 JavaScript 文件，如将 Sass 文件编译成 CSS 或将 ES6 代码转换成普通 JavaScript。

4. **插件（Plugins）**：Webpack 使用插件来执行各种自定义任务，如生成 HTML 文件、压缩 JavaScript 代码、拷贝静态文件等。插件能够在整个构建过程中实现更多的功能和优化。

5. **生成 Chunk**：Webpack 将模块分割成一个个代码块（Chunk）。这通常包括应用代码、第三方库、运行时代码等。Webpack 支持代码分割，以提高性能和缓存。

6. **输出（Output）**：在这一步，Webpack 根据配置文件中的输出路径和文件名规则，将打包后的文件输出到指定目录中。

7. **优化（Optimization）**：Webpack 4+ 提供了强大的优化功能，包括代码分割、压缩、Tree Shaking、缓存等，以确保生成的文件更小、更高效。

8. **生成文件**：Webpack 根据配置生成打包后的文件。这些文件包括 JavaScript、CSS、HTML 和其他资源文件。

9. **Dev Server 或输出到生产环境**：在开发环境中，通常使用 Webpack Dev Server 来提供热重载和开发工具。在生产环境中，生成的文件通常被部署到服务器或 CDN 上，以便用户访问。

Webpack 的打包流程是高度可定制的，你可以通过配置文件来定义入口点、加载器、插件、优化选项和输出规则，以满足你的项目需求。通过了解Webpack的打包流程，你可以更好地理解它的工作原理，提高前端项目的构建效率和性能。

### webpack 的热更新原理是怎样的？
Webpack 的热更新（Hot Module Replacement，HMR）是一项使开发过程更加高效的功能，它可以在不刷新整个页面的情况下，将代码的变更反映到正在运行的应用程序中。HMR 的原理可以简要概括如下：

1. **监听文件变更**：Webpack 开发服务器会监视项目中的文件，包括源代码、样式表、模板等。

2. **构建新模块**：当文件发生变化时，Webpack 会重新构建相应的模块，并生成新的模块代码。

3. **通知更新**：Webpack 会将构建后的模块代码以 JSON 格式发送到客户端。

4. **客户端更新**：客户端接收到更新通知后，会根据新的模块代码来更新应用程序的运行状态，而无需刷新整个页面。

5. **应用局部更新**：HMR 允许模块级别的更新，只有受影响的模块会被替换，而不是整个应用。这有助于保持应用程序的状态和用户输入。

在实际开发中，HMR 的实现通常需要使用相应的插件和加载器，例如 `webpack-dev-server` 插件和 `HotModuleReplacementPlugin` 插件。这些插件负责设置服务器和客户端的通信，以便实现模块热替换。

总的来说，Webpack 的热更新通过监视文件变更、构建新模块、通知客户端以及客户端更新的方式，使开发者可以更加快速地进行前端开发，提高开发效率。这种能力在现代前端开发中非常有用，特别是对于大型应用程序，可以减少开发者等待构建和刷新页面的时间。

### 讲一下你对 webpack5 模块联邦的理解
### 讲一下 webpack5 的模块联邦
Webpack 5 的模块联邦（Module Federation）是一个强大的功能，允许将多个独立的Webpack项目（通常是微前端应用）组合在一起，共享模块和代码。这对于构建分布式、模块化的应用程序非常有用，可以减少冗余代码，提高性能，并简化项目的维护。

以下是关于 Webpack 5 模块联邦的一些重要概念和用法：

1. **远程模块**：模块联邦允许将模块从一个远程Webpack项目导入到另一个项目中。这些远程模块可以是独立的、独立部署的项目。

2. **主应用和子应用**：一个主应用可以加载一个或多个子应用，子应用可以是不同的Webpack项目。主应用和子应用之间可以相互通信和共享模块。

3. **共享模块**：模块联邦支持定义和共享模块，这些模块可以在不同的项目之间共享，以减少冗余代码。共享模块可以是第三方库、工具函数或自定义模块。

4. **动态加载**：可以在运行时动态加载远程模块，这使得按需加载模块成为可能，从而提高性能。

5. **配置**：Webpack 5 模块联邦需要在Webpack配置中进行配置。你需要指定要共享的模块、远程应用的入口点以及如何加载远程模块。

以下是一个示例Webpack配置，演示了如何设置模块联邦：

```javascript
// 主应用的Webpack配置
const path = require('path');
const { ModuleFederationPlugin } = require('webpack').container;

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist'),
  },
  plugins: [
    new ModuleFederationPlugin({
      name: 'mainApp',
      remotes: {
        remoteApp: 'remoteApp@http://localhost:3001/remoteEntry.js',
      },
      shared: ['lodash'],
    }),
  ],
};

// 子应用的Webpack配置
module.exports = {
  // ...
  plugins: [
    new ModuleFederationPlugin({
      name: 'remoteApp',
      library: { type: 'var', name: 'remoteApp' },
      filename: 'remoteEntry.js',
      exposes: {
        './Button': './src/Button',
      },
      shared: ['lodash'],
    }),
  ],
};
```

在上面的示例中，主应用通过 `ModuleFederationPlugin` 配置了模块联邦，远程导入了 `remoteApp` 子应用中的模块，并共享了名为 `lodash` 的模块。

模块联邦使得构建微前端应用变得更加容易，可以将不同的应用拼接在一起，实现更高效的开发和部署策略。它提供了一种强大的工具，帮助开发者构建复杂的分布式应用程序。

### 在 seo 优化方面，前端要从哪些点去考虑？

我：标签语义化、ssr 服务端渲染、img 标签添加 alt 属性来、在 head 中添加 meta 标签、优化网站的加载速度，提高搜索引擎的排名。

### 讲一下浏览器的垃圾回收机制
浏览器的垃圾回收机制是一种用于管理内存的自动化系统，它负责检测和回收不再被程序使用的内存，以便释放资源和避免内存泄漏。浏览器的垃圾回收机制主要针对 JavaScript 的内存管理，以下是其工作原理的关键概念：

1. **标记-清除算法（Mark and Sweep）**：这是最常见的垃圾回收算法之一。它工作方式如下：
   - 首先，垃圾回收器会从根对象（通常是全局对象）开始，标记所有可以从根对象访问到的对象。
   - 然后，它会扫描堆中的所有对象，标记那些已经被访问到的对象。
   - 最后，垃圾回收器会清除那些没有被标记的对象，即未被访问到的对象，释放它们占用的内存。

2. **分代回收**：分代回收是一种优化策略，根据对象的生命周期将内存划分为不同的代。通常，新创建的对象被分配到新生代，较长时间存活的对象被分配到老年代。新生代的垃圾回收更频繁，而老年代的垃圾回收更加耗时。这种策略可以提高性能，因为新生代的对象通常更容易被回收。

3. **引用计数**：虽然主要使用标记-清除算法，但浏览器的垃圾回收机制也包括引用计数。引用计数是一种简单的垃圾回收方法，它跟踪每个对象的引用次数。当引用次数为零时，垃圾回收器会立即回收该对象。然而，引用计数不能有效处理循环引用的情况，因此在现代浏览器中不再被主要使用。

4. **内存泄漏检测**：现代浏览器还内置了内存泄漏检测工具，用于检测页面中的潜在内存泄漏问题。这些工具可以帮助开发者识别和修复导致内存泄漏的问题。

需要注意的是，虽然浏览器的垃圾回收机制能够自动管理内存，但开发者仍然需要注意编写内存友好的代码，避免产生不必要的引用，及时释放不再使用的对象，以减少内存占用并确保良好的性能。此外，了解垃圾回收机制的工作原理对于调试和解决内存问题非常有帮助。

### 讲一下浏览器的渲染流程
浏览器的渲染流程是指当浏览器加载一个网页时，它是如何将网页的 HTML、CSS 和 JavaScript 转换成用户可见的界面的过程。这个过程可以分为多个阶段，通常包括以下主要步骤：

1. **构建DOM树（Document Object Model）**：当浏览器加载HTML文件时，它会解析HTML标记并构建出DOM树，表示页面的结构。DOM树是一个树形结构，由元素节点、文本节点和属性节点组成，它表示了页面的层次结构。

2. **构建CSSOM树（CSS Object Model）**：浏览器加载CSS文件并解析样式规则，然后构建出CSSOM树，表示页面的样式信息。CSSOM树描述了每个元素的计算样式，包括颜色、字体、大小等。

3. **合并DOM和CSSOM树**：浏览器将DOM树和CSSOM树合并成一个渲染树（Render Tree）。渲染树只包括需要呈现在页面上的元素，即已经应用样式的元素。这个过程被称为布局（Layout）或回流（Reflow）。

4. **计算布局**：浏览器计算每个元素在页面中的位置和大小，以确定它们在视口中的确切位置。这个过程会考虑元素的尺寸、边距、边框和定位属性。

5. **绘制（Painting）**：浏览器使用计算出的布局信息，将页面上的每个元素绘制到屏幕上。这个过程被称为绘制或栅格化。

6. **合成（Compositing）**：浏览器将不同图层的绘制结果合成到页面的最终图像中。这包括对透明度、层叠顺序和变换等效果的处理。

7. **渲染到屏幕**：最后，浏览器将最终的图像渲染到用户的屏幕上，显示在浏览器窗口中。

在渲染流程中，浏览器会尽力优化性能，例如通过异步加载资源、使用浏览器缓存、懒加载图片等手段来提高页面加载速度。此外，现代浏览器还支持硬件加速和并行处理，以加速渲染过程。这些优化措施旨在提供更流畅的用户体验。

### 讲一下浏览器多进程的渲染优势

### 谈谈你对浏览器架构的理解
浏览器是复杂的软件应用，其内部架构包含多个组件和层级，以便执行各种任务，从加载网页到呈现内容、处理用户输入和管理网络请求。以下是对浏览器架构的一般理解：

1. **用户界面（User Interface）**：这是浏览器的可见部分，包括地址栏、导航按钮、标签页、书签栏等。用户界面的目标是与用户互动，接受命令，提供反馈。

2. **浏览器引擎（Browser Engine）**：浏览器引擎负责解析HTML和CSS，构建DOM树和CSSOM树，然后将其渲染为用户可见的界面。最著名的浏览器引擎包括WebKit（用于Chrome和Safari）、Gecko（用于Firefox）、Trident（用于旧版IE）。

3. **渲染引擎（Rendering Engine）**：渲染引擎负责将DOM和CSSOM树渲染为可视化页面。它将文档解析成绘制命令，通过绘图API将内容显示在屏幕上。

4. **网络栈（Networking Stack）**：网络栈负责处理网络请求，包括HTTP请求、WebSocket连接等。它处理数据传输、处理Cookie、安全性等。

5. **JavaScript引擎（JavaScript Engine）**：JavaScript引擎负责解释和执行JavaScript代码。常见的JavaScript引擎包括V8（用于Chrome）、SpiderMonkey（用于Firefox）、JavaScriptCore（用于Safari）。

6. **布局引擎（Layout Engine）**：布局引擎负责计算文档元素的位置和大小，以便进行页面布局。WebKit引擎的WebCore包含了布局引擎。

7. **存储（Storage）**：浏览器存储组件负责处理本地存储，包括Cookie、Web存储、IndexedDB等。

8. **多进程架构**：现代浏览器通常采用多进程架构，将浏览器的不同部分放在独立的进程中，以提高性能和安全性。通常包括浏览器进程、渲染进程、GPU进程、插件进程等。

9. **插件系统**：浏览器允许第三方插件扩展其功能，例如Flash插件、广告拦截器、密码管理器等。

10. **开发者工具**：浏览器通常包括内置的开发者工具，用于调试和分析网页。

11. **安全性和隐私保护**：浏览器包括安全性特性，如Sandboxing、同源策略、跨站点请求伪造（CSRF）保护、HTTPS支持等，以确保用户的安全和隐私。

浏览器的架构是复杂的，其中不同的组件协同工作，以提供快速、可靠、安全的网页浏览体验。浏览器不断发展，采用了现代的Web标准，以满足用户和开发者的需求，同时保持性能和安全性。开发者需要了解浏览器架构的工作原理，以优化网页性能和确保跨浏览器兼容性。

### 你讲一下 vue 双向绑定的原理
### 讲一下 vue3 相比 vue2 ，它在 diff 算法上做了哪些优化？
Vue 3 在 diff 算法方面进行了一些优化，以提高性能和减少不必要的渲染。以下是一些 Vue 3 在 diff 算法上的改进：

1. **静态树提升（Static Tree Hoisting）**：Vue 3 引入了静态树提升，通过标记和提升静态树中的不变节点，减少了虚拟DOM的生成和比对成本。这可以减少不必要的重渲染，提高性能。

2. **Fragments 和 Teleport**：Vue 3 引入了Fragments和Teleport，允许在不创建额外的DOM层级的情况下，更轻松地组合和渲染组件。这可以减少虚拟DOM树的复杂性，减少渲染开销。

3. **Diff 策略优化**：Vue 3 改进了虚拟DOM的比对策略，减少了不必要的节点比对。Vue 3的diff算法在处理动态节点时更高效，而Vue 2中使用的双指针算法可能会在某些情况下执行更多的比对操作。

4. **Fragment 和 Teleport 的内置支持**：Vue 3 为Fragments和Teleport提供了内置支持，而在Vue 2中，它们通常需要使用插件或其他解决方案来实现。这意味着更少的外部依赖和更高的性能。

5. **新的编译器（Compiler）**：Vue 3 使用了新的编译器，它生成更优化的渲染函数，进一步减少了运行时开销。

6. **Tree Shaking 支持**：Vue 3 更好地支持Tree Shaking，使开发者能够在应用中只包含实际使用的代码，而不包括未使用的组件和功能。

这些优化使Vue 3在性能方面更加出色，特别是在处理大型、复杂的页面和组件树时。 Vue 3的diff算法和渲染引擎都经过重新设计和改进，以提供更好的性能和更高的效率。这使得Vue 3成为了一个更强大的前端框架，适用于各种类型的应用程序。

### Vue2 为什么要对数组的常用方法进行重写？
Vue 2 之所以对数组的常用方法进行重写，主要是为了实现数据的响应性，以便在数据发生变化时能够自动触发视图的更新。这是 Vue 的核心特性之一，即数据驱动视图，通过建立数据和视图之间的关联，实现了双向绑定。

Vue 2 使用了一个名为"响应性系统"的机制，它依赖于数据的 getter 和 setter 方法，以便在访问或修改数据时能够捕获这些操作，从而实现依赖追踪和自动更新视图。在这个系统中，数组的常用方法（如 push、pop、shift、unshift、splice、sort、reverse）需要被重写，以便在执行这些操作时，能够通知 Vue 哪些数据发生了变化。

具体来说，Vue 2 对数组的重写包括以下关键步骤：

1. **劫持数组方法**：Vue 2 重写了数组的常用方法，例如 `push`、`pop`、`shift` 等，以捕获这些方法的执行。这些重写的方法会先执行原始的数组操作，然后通知 Vue 数据已变更。

2. **派发通知**：当数组方法执行时，Vue 2 会派发通知，告诉依赖于该数组的视图需要更新。这使得 Vue 能够自动追踪依赖关系，确保视图与数据的同步。

3. **深度观察**：Vue 2 还支持深度观察数组内部元素的变化，即当数组元素是对象时，修改对象属性也会触发视图更新。

虽然这种重写数组方法的方式在 Vue 2 中实现了响应式数据，但它也存在一些局限性，如无法捕获直接通过索引修改数组元素的操作。因此，Vue 3 引入了 Proxy-based 响应性系统，可以更灵活地处理数组和对象的变化，无需对数组方法进行重写。这使得 Vue 3 在数组方面的性能和功能上有一些改进。

### Vue 的 nextTick 是怎么实现的？
Vue 的 `nextTick` 方法用于在 DOM 更新后执行回调函数，它可以用于在 Vue 更新视图后执行一些操作，通常是在下一个事件循环中执行，以确保在当前事件循环内的数据变化已经应用到 DOM 上。

`nextTick` 的实现原理主要涉及了 JavaScript 中的事件循环机制。下面是 Vue 的 `nextTick` 如何实现的简要过程：

1. Vue 使用宏任务（Microtasks）和微任务（Microtasks）的机制，宏任务通常在事件循环中排在微任务之后执行。

2. 在 Vue 中，`nextTick` 方法会先检查浏览器是否支持 Promise 对象，如果支持，它会首先使用 Promise 来创建一个微任务。

3. 如果浏览器不支持 Promise，则会回退到使用 MutationObserver（如果支持）来模拟微任务。MutationObserver 是浏览器提供的用于监视 DOM 变化的机制。

4. Vue 会将要执行的回调函数添加到微任务队列中，然后等待下一个事件循环执行。

5. 当浏览器的当前任务（宏任务）执行完毕后，它会去执行微任务队列中的回调函数，这时 `nextTick` 的回调函数就会被执行。

6. `nextTick` 的回调函数中通常包含了需要在 DOM 更新后执行的操作，例如读取更新后的 DOM 元素尺寸或执行一些其他任务。

总之，`nextTick` 利用了 JavaScript 异步机制，确保回调函数在 DOM 更新后执行，从而可以安全地操作更新后的 DOM。这对于处理 Vue 中的数据更新和视图更新非常有用，特别是在需要进行一些与 DOM 相关的操作时。在不同浏览器和环境中，`nextTick` 的实现可能会有所不同，但其核心思想是使用微任务或 MutationObserver 来实现 DOM 更新后的回调。

### 讲一下你对 EventLoop 的理解

### 讲一下 webpack5 的模块联邦

### 讲一下 vue 的生命周期
### 讲一下 computed 与 watch 的区别
### 讲一下 vue 的双向绑定和原理
### 讲一下 vue3 相比 vue2 有哪些提升
Vue 3 相较于 Vue 2 带来了一系列的改进和性能提升，以下是一些 Vue 3 相比 Vue 2 的主要提升：

1. **性能优化**：
   - **更快的渲染性能**：Vue 3 使用了优化的虚拟DOM算法，提供更快的渲染性能。
   - **更小的包大小**：Vue 3 的核心库采用了更好的模块化和Tree-Shaking支持，使得最终的包大小更小。
   - **懒加载**：Vue 3 支持组件的懒加载，只在需要时才加载组件，减少初始加载时间。

2. **Composition API**：Vue 3 引入了 Composition API，它允许组织代码更加灵活，使组件更易维护和理解。它也更容易共享和重用逻辑。

3. **Teleport 和 Suspense**：Vue 3 引入了 Teleport 组件，使得更容易在组件树中移动DOM元素。同时，Suspense 组件使异步数据加载更加简单，可通过等待异步数据渲染组件，而不需要复杂的逻辑。

4. **响应式系统升级**：Vue 3 使用 Proxy 来替代 Object.defineProperty，这带来了更好的性能和更丰富的反应性特性。它还提供了更好的 TypeScript 支持。

5. **更好的TypeScript支持**：Vue 3 提供了更强大的 TypeScript 类型支持，包括组件类型、响应式类型等。

6. **多根节点支持**：Vue 3 放宽了单文件组件的模板要求，允许多个根节点，使得组织复杂的布局更加容易。

7. **Fragments**：Vue 3 引入了 Fragments，可以更容易地组合多个元素而不需要额外的包装。

8. **自定义渲染器**：Vue 3 的架构更加灵活，支持自定义渲染器，可以用于构建不仅限于DOM的渲染目标，例如NativeScript、Weex等。

9. **更好的TypeScript支持**：Vue 3 提供了更强大的 TypeScript 类型支持，包括组件类型、响应式类型等。

总之，Vue 3 带来了许多性能优化、更好的开发体验和更灵活的编程模型。它在响应性、可组合性、性能和开发工具等方面都有显著的改进，使得开发者能够更高效地构建现代的Web应用。当然，在迁移到 Vue 3 时，开发者需要了解新特性和API，以充分利用这些优势。
### seo 优化有了解过吗？讲一下你的见解
### 响应式网站开发你知道哪些方案？

## test
### 1
观察一组数列，写一个方法求出第 31 个数字是什么？（通过观察后，发现那是一组斐波那契数列）
实现一个深拷贝函数
### 写一个通用的方法来获取地址栏的某个参数对应的值，不能使用正则表达式。

### vue3 的 diff 算法做了哪些改进

### vue 双向绑定的原理是什么

### 假设要设计一个全局的弹窗组件你会怎么设计？
设计一个全局的弹窗组件在React中通常包括以下步骤：

1. **组件结构设计**：首先，设计弹窗组件的结构，包括弹窗内容、标题、按钮、关闭按钮等元素。你可以创建一个独立的React组件，例如`Modal`，并在其中渲染这些元素。

2. **状态管理**：为了在应用的不同部分触发和控制弹窗的显示，需要设计一个状态管理系统。通常可以使用React的状态或者Redux等状态管理库来管理弹窗的显示状态。

3. **全局状态**：如果要实现全局的弹窗组件，需要考虑如何在应用的不同组件中触发弹窗的显示。可以将弹窗的显示状态放在全局状态中，例如Redux的store中，以便全局共享。

4. **弹窗触发**：设计一种方式来触发弹窗的显示。可以通过在全局状态中设置标志来控制弹窗的显示与隐藏，也可以通过自定义事件或上下文API来实现。

5. **自定义配置**：为弹窗组件提供自定义配置选项，允许传递不同的弹窗标题、内容、按钮等属性。这可以通过组件属性（props）或函数参数来实现。

6. **样式设计**：设计弹窗的样式，可以使用CSS或CSS-in-JS库来定义样式。确保弹窗可以居中显示并在需要时覆盖整个页面。

7. **事件处理**：处理弹窗内部的事件，例如按钮点击事件、关闭按钮点击事件等。可以通过React事件处理程序来实现这些功能。

8. **动画效果**：如果需要，可以为弹窗添加动画效果，使其更吸引人。可以使用React动画库，如React Transition Group，来实现动画效果。

9. **测试**：编写单元测试和集成测试，以确保弹窗组件的功能正常，并且不会引入潜在的bug。

10. **文档和示例**：为弹窗组件编写文档，提供示例代码和用法说明，以便其他开发者能够轻松使用这个组件。

11. **集成到应用**：将弹窗组件集成到你的React应用中，根据需要在应用的不同部分触发弹窗的显示。

设计一个全局的弹窗组件需要考虑众多细节，但它可以增加应用的交互性和用户友好性。可以根据项目的需求和规模来确定具体的实现方式。

### 如果这个弹窗组件可以弹出多个，
消息会垂直排列，新消息会把旧消息顶起来，每个消息都可以设置一个停留时间，到了时间后就会消失，这一块你会怎么设计？

### 你了解堆这种数据结构吗？讲一讲你对它的理解

### vue3 相比 vue2 做了哪些提升？
### 讲一下 vue3 的 diff 算法吧
Vue 3 的虚拟DOM和diff算法在渲染组件时经历了一系列的步骤。以下是Vue 3的diff算法的基本流程：

1. **数据变更触发**：当组件的数据发生变化，或者触发了`setState`等操作，Vue 3会标记组件为"dirty"，表示需要重新渲染。

2. **生成新虚拟DOM**：Vue 3会生成新的虚拟DOM树，这是一个内存中的虚拟表示，用于描述要渲染的实际DOM结构。新虚拟DOM是基于组件的状态和数据生成的。

3. **Diff算法比对**：Vue 3会将新虚拟DOM与旧虚拟DOM进行比对，以找出差异。这个比对过程是一个深度递归的过程，从根节点开始逐层比对。

4. **Patch（打补丁）**：在比对的过程中，Vue 3会标记出需要进行实际DOM操作的节点，这些标记包括新增节点、删除节点、替换节点和更新节点的操作。这些操作被称为"打补丁"，Vue 3会将这些补丁操作记录下来。

5. **批量更新**：Vue 3会批量处理补丁操作，而不是立即执行。这有助于减少DOM操作的次数，提高性能。

6. **实际DOM更新**：在批量处理完补丁操作后，Vue 3会将这些操作应用于实际的DOM树，使其与新虚拟DOM树保持一致。这包括插入新节点、删除不需要的节点、更新已有节点的属性等。

7. **更新组件状态**：Vue 3会更新组件的状态，确保与新虚拟DOM树保持一致，以便下一次渲染时可以使用新状态生成新虚拟DOM。

8. **生命周期钩子触发**：在更新完成后，Vue 3会触发适当的生命周期钩子，如`beforeUpdate`和`updated`，以便开发者可以执行一些附加的操作。

总的来说，Vue 3的diff算法通过虚拟DOM比对，找出需要变更的部分，然后批量更新实际的DOM，以保持UI与数据的一致性。这个算法在性能上进行了多项优化，例如静态树提升、PatchFlag、缓存策略等，以提供更快的渲染速度和更高的效率。这也使Vue 3成为一个强大的前端框架，适用于各种规模的应用。

### 讲一下 V8 的垃圾回收机制
### 讲一下 chrome 是如何渲染一个网页的
### 大文件分块上传以及断点续传，你会怎么实现
实现大文件分块上传和断点续传通常需要以下步骤：

1. **文件分块**：将大文件分割成小块，每个小块的大小由你决定，通常为几兆字节。可以使用JavaScript的`File` API来读取文件内容并分割。

2. **上传分块**：逐个上传分块到服务器。你可以使用HTTP POST请求来上传每个分块，使用FormData对象将分块数据包装成表单数据。确保每个分块都有一个唯一的标识，以便服务器能够正确地组装它们。

3. **断点续传**：在上传分块时，服务器需要记录已经接收的分块，通常可以使用数据库或文件系统来存储已上传的分块信息。如果上传中断，下次继续上传时可以根据已上传的分块信息来确定从哪个分块开始。

4. **合并分块**：一旦所有分块都上传完毕，服务器将它们合并成完整的文件。你可以根据每个分块的标识来确定它们的顺序，并将它们按顺序合并成一个完整的文件。

5. **清理**：在文件上传完成后，你可以清理服务器上的临时分块和相关信息。

6. **前端进度条**：为了提供用户友好的界面，你可以在前端实现一个上传进度条，以显示文件上传的进度。

7. **错误处理**：在整个过程中需要处理可能出现的错误，例如网络问题、服务器问题、分块损坏等。确保有错误处理机制，可以中断上传并恢复。

8. **安全性**：考虑文件上传的安全性，确保只有授权用户可以上传文件，并验证文件类型和内容。

这是一个高级的任务，需要深入理解前端和后端开发，以及文件处理、网络通信和数据库管理等方面的知识。通常，开发者会使用一些流行的库或框架来简化这个过程，例如`axios`或`fetch`用于HTTP请求，`express`或`Django`用于服务器端处理等。还可以考虑使用云存储服务，如AWS S3，来存储大文件并提供断点续传的支持。

## test4
###  watch 与 computed 的区别

### vue3 中组件通信都有哪些方式？
Vue 3 中有多种方式可以实现组件通信，根据需求和场景的不同，你可以选择适合的方式：

1. **Props/自定义属性**：通过将数据作为属性传递给子组件，父组件可以向子组件传递数据。这是一种父子组件通信的常见方式。子组件通过`props`接收来自父组件的数据。

2. **自定义事件**：父组件可以通过自定义事件向子组件发送消息。子组件可以使用`$emit`触发事件，而父组件可以监听这些事件并执行相应的操作。

3. **$emit/$on**：除了父子组件之间的通信，Vue 3 允许在任意两个组件之间建立通信渠道。你可以使用`$emit`和`$on`来建立自定义事件通信，而不仅仅限于父子组件之间。

4. **Provide/Inject**：使用`provide`和`inject`可以在父组件和子组件之间建立一种"祖先-后代"关系的通信。祖先组件通过`provide`提供数据，而后代组件通过`inject`访问这些数据。

5. **全局事件总线**：你可以创建一个全局事件总线（Event Bus）来进行组件通信。这是一种非常灵活的方式，但也容易导致混乱。在Vue 3中，你可以使用`mitt`库来创建事件总线。

6. **Vuex**：对于大型应用或需要跨组件通信的情况，可以使用Vuex来管理全局状态。Vuex提供了一种集中式的状态管理方法，允许多个组件共享和修改同一状态。

7. **Router参数**：如果你的应用使用Vue Router，你可以通过路由参数来进行组件通信。参数可以通过路由链接传递，也可以通过路由的`query`或`params`属性传递。

8. **事件总线库**：除了Vue自带的通信方式，还有一些第三方事件总线库，如`mitt`、`tiny-emitter`等，可以用来处理组件通信。

选择合适的通信方式取决于你的应用的需求和架构。对于简单的父子组件通信，`props`和自定义事件通常足够了。对于复杂的状态管理和跨组件通信，考虑使用`Vuex`或其他全局状态管理方法。

### vuex 刷新后数据会丢失，除了把数据放本地存储外，你还知道其他什么方法吗？
保持 Vuex 数据在页面刷新后不丢失的方法之一是将数据保存在本地存储中（如LocalStorage或SessionStorage）。这是一种常见的方法，但还有其他一些方法可以考虑：

1. **使用持久化插件**：Vuex支持使用一些第三方插件来实现数据的持久化。例如，`vuex-persistedstate`插件可以帮助将Vuex状态保存在本地存储中，并在页面刷新后恢复状态。

2. **使用Cookie**：你可以使用Cookie来存储一些小型的状态数据，尤其是用户会话信息。Cookies在浏览器中是持久的，但容量有限。

3. **服务端渲染**：如果你的应用是服务端渲染（SSR）的，那么Vuex的状态通常在服务端和客户端之间共享，不容易丢失。

4. **使用IndexedDB**：IndexedDB是浏览器的数据库系统，可以用来存储大量数据。虽然它比LocalStorage复杂，但可以存储大量数据并支持离线操作。

5. **自定义持久化方案**：你可以实现自定义的持久化方案，将Vuex状态保存在服务器上或其他外部存储中。这需要更多的工作，但可以满足特定需求。

无论采用哪种方法，都需要考虑数据的安全性和隐私，特别是敏感信息。还要谨慎处理数据的版本控制，以避免与缓存和更新相关的问题。根据你的应用需求和架构，选择最合适的方法来保存Vuex数据以保证数据在页面刷新后不丢失。

## 1.window方法，window.onload,ready的加载机制，window获取url参数的方法
1. window.onload是一个事件处理程序，当整个页面及其所有外部资源（如图像和样式表）都已加载完成时触发。可以将函数分配给window.onload属性，以在页面加载完成后执行特定的操作。例如：
```js
window.onload = function() {
  // 在页面加载完成后执行的代码
};
```
2. Query库中的ready事件，它在DOM树构建完毕后触发，而无需等待外部资源（如图像）加载完成。与window.onload不同，ready事件可以在页面的其他资源加载完成之前执行。
```js
$(document).ready(function() {
  // 在DOM准备就绪后执行的代码
});
```

3. 使用window.location.search来获取当前页面URL中的查询参数部分。例如，对于URL https://example.com/?name=John&age=25，可以使用以下代码获取参数值：
```js
var urlParams = new URLSearchParams(window.location.search);
var name = urlParams.get('name'); // "John"
var age = urlParams.get('age'); // "25"
```

## 2. 一个页面和一个弹窗一起，怎么设置弹窗透明不影响页面
使用CSS的opacity属性来控制弹窗的透明度。同时，你还可以使用CSS的pointer-events属性来控制弹窗是否响应用户的交互事件，以避免弹窗遮挡住页面元素。

```html
<div class="page-content">
  <!-- 页面内容 -->
</div>

<div class="modal">
  <!-- 弹窗内容 -->
</div>

.page-content {
  /* 页面内容样式 */
}

.modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.5); /* 设置透明度为 0.5 */
  opacity: 1; /* 设置透明度为 1，如果需要完全透明，可以设置为 0 */
  pointer-events: none; /* 禁用弹窗的交互事件 */
  /* 弹窗样式 */
}
```

## 3. 后端是如何重定向的？
在后端，重定向是通过向客户端发送特定的HTTP响应来实现的。当服务器收到一个请求并决定将客户端重定向到另一个URL时，它会发送一个包含重定向状态码和目标URL的HTTP响应。

最常用的重定向状态码是：

* 301 Moved Permanently：永久重定向，表示目标URL已永久更改。
* 302 Found / 302 Moved Temporarily：临时重定向，表示目标URL是临时性的，请求的资源仍然可以在原始URL上找到。
* 307 Temporary Redirect：临时重定向，与302类似，表示目标URL是临时性的。
```js
// 301 Moved Permanently
app.get('/old-url', (req, res) => {
  res.redirect(301, '/new-url');
});

// 302 Found
app.get('/old-url', (req, res) => {
  res.redirect(302, '/new-url');
});
```

```java
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

// 301 Moved Permanently
response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
response.setHeader("Location", "/new-url");

// 302 Found
response.sendRedirect("/new-url");

/*
对于永久重定向（301 Moved Permanently），我们使用setStatus()方法并传递HttpServletResponse.SC_MOVED_PERMANENTLY作为状态码。然后，使用setHeader()方法设置Location响应头，将其值设置为新的URL。

对于临时重定向（302 Found），我们可以直接使用sendRedirect()方法，并将新的URL作为参数传递给它。
*/
```

## 给出一个数组求最大值用什么方法，这个方法的原理
1. 遍历比较法：
```js
const array = [5, 2, 9, 1, 7];
let max = array[0]; // 初始时将第一个元素作为当前最大值

for (let i = 1; i < array.length; i++) {
  if (array[i] > max) {
    max = array[i]; // 更新当前最大值
  }
}

console.log("最大值：" + max);
```

2. max
```js
const array = [5, 2, 9, 1, 7];
const max = Math.max(...array);

console.log("最大值：" + max);
```