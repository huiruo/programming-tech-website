## 字典，也称为符号表，也称为索引
符号表有时又叫做索引，即书本最后将术语按照字母顺序列出以方便查找的那部分。在一本书的索引中，键就是术语，而值就是书中该术语出现的所有页码。

在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。
字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射、符号表或关联数组。

集合表示一组互不相同的元素（不重复的元素）。

在计算机科学中，字典经常用来保存对象的引用地址。例如，打开Chrome | 开发者工具中的Memory标签页，执行快照功能，

我们就能看到内存中的一些对象和它们对应的地址引用

与Set类相似，ECMAScript2015同样包含了一个Map类的实现，即我们所说的字典。


## 集合、字典和散列表可以存储不重复的值
集合、散列表与字典都是用来存储唯一值(不重复的值)的数据结构。
* 在集合中，存的只有值
```
集合以[值，值]的形式存储元素
字典则是以[键，值]的形式来存储元素。JS中map就是典型的字典结构
```
* 在字典中，我们用[键，值]的形式来存储数据。
* 在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同

## 散列表
散列表（Hash Table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

JavaScript的对象(Object)，本质上是键值对的集合(Hash结构)，但是传统上只能用字符串当作键，因此ES2015 带来了Map类和Map类的弱化版本WeakMap类。

### 复杂度
散列表是根据关键码值而直接进行访问的数据结构，即通过关键码将值映射到表中的某个位置来存储和访问，以加快查找的速度。
哈希表是字典的实现原理，字典通过哈希表来存储数据，而读取的时候也是通过哈希表来获取对应的值。
无论哈希表中有多少数据，增删操作的时间复杂度都为O(1),相当于无须查找，直接定位对其操作。

## 散列算法
散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果要在数据结构中获得一个值（使用get方法），需要迭代整个数据结构来找到它。

如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。
```
散列算法的作用是尽可能快地在数据结构中找到一个值。如果要在数据结构中获得一个值（使用get 方法），需要迭代整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。如下图所示：
https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67868453babe483487d256e469130ac9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp
```

散列表有一些在计算机科学中应用的例子。因为它是字典的一种实现，所以可以用作关联数组。它也可以用来对数据库进行索引。
当我们在关系型数据库（如MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，
一个不错的做法是同时创建一个索引来更快地查询到记录的key。在这种情况下，散列表可以用来保存键和对表中记录的引用。

另一个很常见的应用是使用散列表来表示对象。JavaScript语言内部就是使用散列表来表示每个对象。
此时，对象的每个属性和方法（成员）被存储为key对象类型，每个key指向对应的对象成员。

## 散列冲突和时间复杂度
当不同的key得到相同的hash值时，就会产生冲突，使得后面的value覆盖前面的value;处理冲突有几种方法：分离链接、线 性探查和双散列法。

散列表的时间复杂度主要取决于散列函数的设计和散列表的实现方式。在理想情况下，查找、插入和删除的平均时间复杂度都是O(1)，但实际情况中可能会出现哈希冲突，导致一些操作的时间复杂度增加到O(n)。因此，选择合适的散列函数和冲突解决方法是非常重要的。

## 哈希表是怎么存储数据？
```
现在有一个数组，它里面每个单元存储的是数据的地址

这叫指针数组吧，假设它有100个单元

我们称他为p[100]

现在我想把一百个数据（地址）放到里面

我们想把某个数据放到p的第几个单元完全是由

我们决定的，可以说想怎么放就怎么放

是一种乱放，既然是乱放，那么查找起来就比较耗时。
```

哈希表同样是一个指针数组。

同样需要存储100个数据，需要的就不是100个单元了，因为哈希表要把某个数据存放在某个单元不是随机的一个过程，而是算出来的，这个算法叫哈希函数

比如要存储一个数据对
```
张三 1882356
李四  23456789
王五  58856456
```
张三经过哈希函数算出来的值是138，那么哈希表最少需要138个单元，因为张三对应的数据1882356要存储在指针数组的p[138]的位置上。

李四经过哈希函数算出来的值是500，那么2356789这个数据就要存放在p[500]这个位置上。

所以，"数据的地址放在指针数组的哪个单元格是算出来的，是有迹可寻的，并不是想放在哪里就放在哪里"

那查找的时候就好查找了，你要查找张三对应的数据，直接把张三用哈希函数算一下，得到138，张三的数据就在p[138]这个位置上，所以一下就找到了。

哈希表是一个key-value的数据对，p是一个指针数组，用来存放value的地址，那么key和value的关系是下面这样的。
```
p[f(key)]=&value
```

哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。

## HashMap的存取
HashMap的功能是通过“键(key)”能够快速的找到“值”。下面我们分析下HashMap存数据的基本流程：
* 1、 当调用put(key,value)时，首先获取key的hashcode，int hash = key.hashCode();
* 2、 再把hash通过一下运算得到一个int h.
hash ^= (hash >>> 20) ^ (hash >>> 12);  // >>>是无符号的右移运算， 高位直接补零，低位移除。>>表示带符号的右移运算， 高位如果符号位为正补零，符号位负补一，低位直接移除

hash = hash ^ (hash >>> 20) ^ (hash >>> 12)； ^代表异或运算

int h = hash ^ (hash >>> 7) ^ (hash >>> 4);

为什么要经过这样的运算呢？这就是HashMap的高明之处。先看个例子，一个十进制数32768(二进制1000 0000 0000 0000)，经过上述公式运算之后的结果是35080(二进制1000 1001 0000 1000)。看出来了吗？或许这样还看不出什么，再举个数字61440(二进制1111 0000 0000 0000)，运算结果是65263(二进制1111 1110 1110 1111)，现在应该很明显了，它的目的是让“1”变的均匀一点，散列的本意就是要尽量均匀分布。那这样有什么意义呢？看第3步。
* 3、 得到h之后，把h与HashMap的承载量（HashMap的默认承载量length是16，可以自动变长。在构造HashMap的时候也可以指定一个长 度。这个承载量就是上图所描述的数组的长度。）进行逻辑与运算，即 h & (length-1)，这样得到的结果就是一个比length小的正数，我们把这个值叫做index。其实这个index就是索引将要插入的值在数组中的 位置。第2步那个算法的意义就是希望能够得出均匀的index，这是HashTable的改进，HashTable中的算法只是把key的 hashcode与length相除取余，即hash % length，这样有可能会造成index分布不均匀。还有一点需要说明，HashMap的键可以为null，它的值是放在数组的第一个位置。
* 4、 我们用table[index]表示已经找到的元素需要存储的位置。先判断该位置上有没有元素（这个元素是HashMap内部定义的一个类Entity， 基本结构它包含三个类，key，value和指向下一个Entity的next）,没有的话就创建一个Entity<K,V>对象，在 table[index]位置上插入，这样插入结束；如果有的话，通过链表的遍历方式去逐个遍历，看看有没有已经存在的key，有的话用新的value替 换老的value；如果没有，则在table[index]插入该Entity，把原来在table[index]位置上的Entity赋值给新的 Entity的next，这样插入结束。
