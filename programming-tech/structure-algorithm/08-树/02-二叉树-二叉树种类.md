---
title: 二叉树-二叉树种类
sidebar_position: 1
---

# 二叉树的种类

## 二叉树的定义
```
      1
    /   \
  2     3
  / \   / \
4   5 6   7
```
其中每个节点最多有两个子节点，称为左子节点和右子节点。如果某个节点没有子节点，则它被称为叶节点或叶子。树的最上层节点被称为根节点。

在二叉树中，左子树和右子树也是二叉树，它们由根节点的左右子节点形成。

这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。
```
1. 存储有层级关系的数据。二叉树可以用来表示具有层级关系的数据，例如组织机构、文件系统等。每个节点表示一个实体，节点之间的层级关系表示实体之间的关系。

2. 快速查找、插入、删除数据。二叉树的节点之间存在一定的有序性，可以利用这个特点进行快速的查找、插入、删除操作。二叉搜索树是一种常用的数据结构，它可以实现快速的查找、插入、删除操作，时间复杂度为 O(log n)。

3. 提供排序功能。二叉搜索树可以对数据进行排序，排序后的数据可以方便地进行查找和遍历操作。

4. 作为其他数据结构的基础。二叉树是许多其他数据结构的基础，例如红黑树、AVL树、堆等。这些数据结构可以实现更高级的功能，例如高效地维护有序数据、实现优先队列等。
```

二叉树的遍历方式包括前序遍历、中序遍历和后序遍历。

## 1.二叉搜索树
BST 树，全称为二叉搜索树（Binary Search Tree），是一种基于二分查找的二叉树结构，它的每个节点都包含一个关键字，且所有节点的关键字都满足以下条件：
1. 每个节点的值都大于其左子树中任意一个节点的值
2. 每个节点的值都小于其右子树中任意一个节点的值
3. 左右子树都是二叉搜索树
```
      6
    /   \
  4     9
  / \   / \
2   5 8  10
```
BST 树的主要特点是支持快速的查找、插入和删除操作，时间复杂度均为 O(log n)，其中 n 是树中节点的数量。具体地，对于查找操作，从根节点开始，不断与目标关键字比较，根据比较结果选择左子树或右子树继续查找，直到找到目标节点或遇到空节点为止。对于插入和删除操作，首先需要按照查找的方式找到待插入或待删除节点，然后根据具体情况进行节点的插入或删除操作，最后通过调整树的结构保持树的平衡性。

BST 树的缺点是，如果节点的插入顺序不合理，可能会导致树的不平衡，从而影响树的性能。例如，如果将节点按照递增或递减的顺序插入，则 BST 树会退化成一条链表，使得查找操作的时间复杂度退化为 O(n)，其中 n 是树中节点的数量。因此，在实际应用中，需要采取一些措施来保证 BST 树的平衡性，比如使用 AVL 树、红黑树等自平衡二叉树。

## 2.自平衡树
自平衡树（Self-Balancing Tree）是一类具有自动平衡性质的二叉查找树（Binary Search Tree），它能够在每次插入或删除节点时自动调整树的结构，使得整棵树始终保持平衡状态，从而保证了树中操作的最坏时间复杂度不超过 O(log n)，其中 n 为树中节点的数量。

常见的自平衡树包括
* AVL 树
* 红黑树
* 替罪羊树
* Treap 树等。这些树的自平衡策略不同，但它们都具有一定的自动平衡性质，能够保持树的平衡状态。

自平衡树的应用十分广泛，它们可以用于实现高效的数据结构，比如关联数组、集合、有序集合等。在实际应用中，自平衡树往往比普通的二叉查找树效率更高，因为它们能够保持树的平衡状态，从而减少了树的高度，使得查找、插入、删除等操作的复杂度更低。

## 3.自平衡树之红黑树
详见另外文件:例3-1-红黑树.md

## 4.自平衡树之AVL 树
AVL 树是一种自平衡二叉查找树，它能够在每次插入或删除节点时自动调整树的结构，使得整棵树始终保持平衡状态。AVL 树的平衡性是通过树中每个节点的平衡因子来维护的，平衡因子是该节点的左子树高度减去右子树高度的差值，因此平衡因子的取值范围为 -1、0、1。

AVL 树的平衡维护策略是：对于任意节点，其左右子树的高度差不超过1，如果不平衡，则通过旋转操作使之恢复平衡状态。AVL 树的旋转操作包括左旋和右旋，左旋是将某个节点的右子树提升为新的父节点，而右旋是将某个节点的左子树提升为新的父节点。

AVL 树的优点是：查询、插入、删除等操作的时间复杂度都是 O(log n)，其中 n 是树中节点的数量。缺点是，由于 AVL 树需要维护平衡状态，所以插入和删除节点时需要进行频繁的旋转操作，导致插入和删除操作的效率较低。

AVL树是另一种常见的自平衡树，它的平衡条件比红黑树更为严格，保证了树的高度不会超过1.44log(N+2)-0.328，其中N是树中节点的个数。在AVL树中，每个节点都有一个平衡因子（balance factor），表示左子树高度和右子树高度的差。满足以下性质：
* 每个节点的平衡因子只能是-1、0、1三种之一
* 左子树和右子树的高度差不能超过1
```
          10(-1)
        /      \
       5(0)     20(0)
              /     \
            15(0)   30(1)
                   /   \
                  25(0) 40(0)
```


## 实例：二叉搜索树
二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。

二叉搜索树数据结构的组织方式。
![](../../assets/img-algorithm/图2树.png)

```
和链表一样，我们将通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）。

在双向链表中，每个节点包含两个指针，一个指向下一个节点，另一个指向上一个节点。

对于树，使用同样的方式（也使用两个指针），但是一个指向左侧子节点，另一个指向右侧子节点。
因此，将声明一个Node类来表示树中的每个节点。

值得注意的一个小细节是，不同于在之前的章节中将节点本身称作节点或项，我们将会称其为键（行{1}）。键是树相关的术语中对节点的称呼。
```

## 如03例子
```
insert(key)：向树中插入一个新的键。
search(key)：在树中查找一个键。如果节点存在，则返回true；如果不存在，则返回false。
inOrderTraverse()：通过中序遍历方式遍历所有节点。
preOrderTraverse()：通过先序遍历方式遍历所有节点。
postOrderTraverse()：通过后序遍历方式遍历所有节点。
min()：返回树中最小的值/键。
max()：返回树中最大的值/键。
remove(key)：从树中移除某个键
```

## 要向树中插入一个新的节点（或键），要经历三个步骤
第一步是验证插入操作是否是特殊情况。对于二叉搜索树的特殊情况是，我们尝试插入的树节点是否为第一个节点（行{1}）。
如果是，我们要做的就是创建一个Node类的实例并将它赋值给root属性来将root指向这个新节点（行{2}）。
因为在Node构建函数的属性里，只需要向构造函数传递我们想用来插入树的节点值（key），它的左指针和右指针的值会由构造函数自动设置为null。

第二步是将节点添加到根节点以外的其他位置。在这种情况下，我们需要一个辅助方法（行{3}）来帮助我们做这件事，它的声明如下。

```js
insert(key) {
    // special case: first key
    if (this.root == null) { // 1
        this.root = new Node(key); //2
    } else {
        this.insertNode(this.root, key); //3
    }
}

// insertNode方法会帮助我们找到新节点应该插入的正确位置。
/*
如果树非空，需要找到插入新节点的位置。因此，在调用insertNode方法时要通过参数传入树的根节点和要插入的节点。

如果新节点的键小于当前节点的键（现在，当前节点就是根节点）（行{4}），那么需要检查当前节点的左侧子节点。
注意在这里，由于键可能是复杂的对象而不是数，我们使用传入二叉搜索树构造函数的compareFn函数来比较值。
如果它没有左侧子节点（行{5}），就在那里插入新的节点（行{6}）。如果有左侧子节点，需要通过递归调用
insertNode方法（行{7}）继续找到树的下一层。
在这里，下次要比较的节点将会是当前节点的左侧子节点（左侧节点子树）。

如果节点的键比当前节点的键大，同时当前节点没有右侧子节点（行{8}），就在那里插入新的节点（行{9}）。
如果有右侧子节点，同样需要递归调用insertNode方法，但是要用来和新节点比较的节点将会是右侧子节点（右侧节点子树）（行{10}）。
* */
insertNode(node, key) {
    if (this.compareFn(key, node.key) === Compare.LESS_THAN) { //4
      if (node.left == null) {  //5
        node.left = new Node(key); //6
      } else {
        this.insertNode(node.left, key); // 7
      }
    } else if (node.right == null) { //8
      node.right = new Node(key); // 9
    } else {
      this.insertNode(node.right, key); // 10
    }
}
```

## 树的遍历
访问树的所有节点有三种方式：中序、先序和后序。
