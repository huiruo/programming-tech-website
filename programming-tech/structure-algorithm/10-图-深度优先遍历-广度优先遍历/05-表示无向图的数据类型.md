
##  1-1.无向图api
```
public class Graph

Graph(int V)    创建一个含有 个顶点但不含有边的图
Graph(In in)    从标准输入流 in 读入一幅图
int V()         顶点数
int E()  边数
void addEdge(int v, int w) 向图中添加一条边 v-w
Iterable<Integer>adj(int v) 和 v 相邻的所有顶点
String toString()   对象的字符串表示
```

##  1-2.图的几种表示方法
我们要面对的下一个图处理问题就是用哪种方式（数据结构）来表示图并实现这份 API，这包含以下两个要求：
1.它必须为可能在应用中碰到的各种类型的图预留出足够的空间；
2.Graph 的实例方法的实现一定要快——它们是开发处理图的各种用例的基础。

三种图表示方法：
```
1.邻接矩阵。我们可以使用一个V 乘V 的布尔矩阵。当顶点 v 和顶点 w 之间有相连接的边时，定义 v 行 w 列的元素值为 true，
否则为 false。 这种表示方法不符合第一个条件——含有上百万个顶点的图是很常见的， V^2个布尔值所需的空间是不能满足的.

2.边的数组。我们可以使用一个 Edge 类，它含有两个 int 实例变量。这种表示方法很简洁但不满足第二个条件——要实现 adj() 需要检查图中的所有边。

3.邻接表数组。我们可以使用一个以顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表,这种数据结构能够同时满足典型应用所需的以上两个条件，
我们会在本章中一直使用它。
```

##  1-3.邻接表的数据结构
```
非稠密图的标准表示称为邻接表的数据结构，它将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。
我们使用这个数组就是为了快速访问给定顶点的邻接顶点列表。
```

##  1-4.图的处理算法的设计模式
```
因为我们会讨论大量关于图处理的算法，所以设计的首要目标是将图的表示和实现分离开来。为此，我们会为每个任务创建一个相应的类，
用例可以创建相应的对象来完成任务。类的构造函数一般会在预处理中构造各种数据结构，以有效地响应用例的请求
```
图处理算法的 API
```
public class Search{
Search(Graph G, int s)  找到和起点 s 连通的所有顶点
boolean marked(int v)   v 和 s 是连通的吗
int count() 与 s 连通的顶点总数
}

我们用起点（source）区分作为参数传递给构造函数的顶点与图中的其他顶点。在这份 API 中，构造函数的任务是找到图中与起点连通的其他顶点。
用例可以调用 marked() 方法和 count() 方法来了解图的性质。方法名 marked() 指的是这种基本算法使用的一种实现方式

本章中会一直使用到这种算法：在图中从起点开始沿着路径到达其他顶点并标记每个路过的顶点。
```

##  1-4-2.深度优先搜索
```
我们已经见过 Search API 的一种实现：第 1 章中的 union-find 算法。
它的构造函数会创建一个 UF 对象，对图中的每一条边进行一次 union() 操作并调用 connected(s,v) 来实现 marked(v) 方法。
实现 count() 方法需要一个加权的 UF 实现并扩展它的 API，以便使用 count() 方法返回 wt[find(v)]（请见练习 4.1.8）。

这种实现简单而高效，但下面我们要学习的实现还可以更进一步。它基于的是深度优先搜索（DFS）的。这是一种重要的递归方法，
它会沿着图的边寻找和起点连通的所有顶点。深度优先搜索是本章中将学习的好几种关于图的算法的基础。
```

##  1-4-3.深度优先搜索定义
```
要搜索一幅图，只需用一个递归方法来遍历所有顶点。在访问其中一个顶点时：
1.将它标记为已访问；
2.递归地访问它的所有没有被标记过的邻居顶点。

这种方法称为深度优先搜索（DFS）。Search API 的一种实现使用了这种方法，如深度优先搜索框注所示。
它使用一个 boolean 数组来记录和起点连通的所有顶点。
递归方法会标记给定的顶点并调用自己来访问该顶点的相邻顶点列表中所有没有被标记过的顶点。如果图是连通的，每个邻接链表中的元素都会被检查到。
```

```
我们常常通过系统地检查每一个顶点和每一条边来获取图的各种性质。
要得到图的一些简单性质（比如，计算所有顶点的度数）很容易，只要检查每一条边即可（任意顺序）。

但图的许多其他性质和路径有关，因此一种很自然的想法是沿着图的边从一个顶点移动到另一个顶点。尽管存在各种各样的处理策略，
但后面将要学习的几乎所有与图有关的算法都使用了这个简单的抽象模型，其中最简单的就是下面介绍的这种经典的方法。
```

##  1-4-4.深度优先搜索 使用场景
```
这种简单的递归模式只是一个开始——深度优先搜索能够有效处理许多和图有关的任务。

用深度优先搜索来解决在第 1 章首次提到的一个问题。 连通性。给定一幅图，回答“两个给定的顶点是否连通？”或者“图中有多少个连通子图？”等类似问题。

但是，在 1.5 节学习的 union-find 算法的数据结构并不能解决找出这样一条路径的问题。深度优先搜索是我们已经学习过的几种方法中第一个能够解决这个问题的算法。

单点路径。给定一幅图和一个起点 s，回答“从 s 到给定目的顶点 v 是否存在一条路径？如果有，找出这条路径。”等类似问题。
深度优先搜索算法之所以极为简单，是因为它所基于的概念为人所熟知并且非常容易实现。事实上，它是一个既小巧而又强大的算法，研究人员用它解决了无数困难的问题。
```

##  1-4-5.寻找路径
单点路径问题在图的处理领域中十分重要。根据标准设计模式，我们将使用如下 API:
```
public class Paths{
    Paths(Graph G, int s)       在 G 中找出所有起点为 s 的路径
    boolean hasPathTo(int v)    是否存在从 s 到 v 的路径
    Iterable<Integer>pathTo(int v) s 到 v 的路径，如果不存在则返回 null
}

在为起点 s 创建了 Paths 对象后，用例可以调用 pathTo() 实例方法来遍历从 s 到任意和 s 连通的顶点的路径上的所有顶点。
```
