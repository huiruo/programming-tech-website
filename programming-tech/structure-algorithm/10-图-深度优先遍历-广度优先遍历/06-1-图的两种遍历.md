##  图两种遍历方法
图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等。

以上是图论中两种非常重要的算法,生产上广泛用于拓扑排序，寻路(走迷宫)，搜索引擎，爬虫等，也频繁出现在 leetcode，高频面试题中。

图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。
对于两种图遍历算法，都需要明确指出第一个被访问的顶点。

完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，
并将其加进待访问顶点列表中。为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。

对于树或图结构的搜索(或遍历)来讲, 分为深度优先(DFS)和广度优先(BFS):
* 广度优先搜索（breadth-first search，BFS）
* 深度优先搜索（depth-first search，DFS）。 DFS 的主流实现方式有 2 种
```
1.递归(简单粗暴)
2.利用栈存储遍历路径
```

广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构，如下表所示。
算法        数据结构                    描述

深度优先搜索  栈      将顶点存入栈（在第4章中学习过），顶点是沿着路径被探索的，存在新的相邻顶点就去访问

广度优先搜索  队列     将顶点存入队列（在第5章中学习过），最先入队列的顶点先被探索

## 深度优先搜索（DFS）
从起点开始，每次遍历到一个未访问过的相邻节点，就将该节点标记为已访问，然后继续从该节点开始深度优先遍历，直到到达某个节点的所有相邻节点都已被访问过为止。如果在遍历过程中发现没有可访问的相邻节点，则返回上一级节点继续遍历。DFS通常使用栈数据结构实现。

在程序中，在搜索一幅图时遇到有多条边需要遍历的情况时，我们会选择其中一条并将其他通道留到以后再继续搜索。

在深度优先搜索中，我们用了一个可以下压的栈（这是由系统管理的，以支持递归搜索方法）。使用 LIFO（后进先出）的规则来描述压栈和走迷宫时先探索相邻的通道类似。从有待搜索的通道中选择最晚遇到过的那条。

## 广度优先搜索（BFS）
从起点开始，将起点加入到一个队列中，每次从队列中取出队首元素进行访问，将该节点的所有未访问相邻节点加入队列尾部，标记为已访问。继续重复该过程，直到找到目标节点或队列为空为止。BFS通常使用队列数据结构实现。

因此，DFS通常会沿着深度方向搜索，先发现深度较大的节点，而BFS通常会沿着广度方向搜索，先发现与起点距离较近的节点。在最坏情况下，DFS的时间复杂度可能会变成指数级别，而BFS的时间复杂度通常为O(n)。在某些情况下，DFS可能更适用于查找深度较小的解决方案，而BFS更适用于查找最短路径。

要找到从 s 到 v 的最短路径，从 s 开始，在所有由一条边就可以到达的顶点中寻找 v，
如果找不到我们就继续在与 s 距离两条边的所有顶点中查找 v，如此一直进行。

在广度优先搜索中，我们希望按照与起点的距离的顺序来遍历所有顶点，看起来这种顺序很容易实现：
使用（FIFO，先进先出）队列来代替栈（LIFO，后进先出）即可。我们将从有待搜索的通道中选择最早遇到的那条。
```
深度优先搜索就好像是一个人在走迷宫，但是广度优先搜索则好像是一组人在一起朝各个方向走这座迷宫，每个人都有自己的绳子。

当出现新的叉路时，可以假设一个探索者可以分裂为更多的人来搜索它们，当两个探索者相遇时，会合二为一（并继续使用先到达者的绳子）
```
## 二者哪个性能更好
深度优先搜索和广度优先搜索的性能取决于具体的问题和数据结构。

* 一般来说，如果解决问题的答案距离起点较近，那么使用广度优先搜索会更快；

* 如果答案距离起点较远或者没有解，使用深度优先搜索可能更快，因为深度优先搜索在搜索路径上尽可能深入，可以更快地排除不可能的解，而广度优先搜索则需要访问更多的节点才能找到解。

此外，还要考虑数据结构的特点，例如图的大小、稀疏程度、节点的度数等等，都会影响算法的性能。在某些情况下，可以结合两种搜索算法的优点，例如使用双向搜索等技术来提高搜索效率。

## 假设我们要在以下图中查找节点8是否存在：
```
      1
     / \
    2   3
   / \   \
  4   5   6
 /     \  |
7       8 9
```

* 使用DFS，我们从节点1开始，首先访问节点2，然后访问节点4，由于节点4没有相邻节点，我们返回节点2，然后访问节点5，发现它有一个相邻节点8，找到了目标节点，返回true。DFS会先搜索较深的分支，因此会先找到节点8。

* 使用DFS，我们从节点1开始，首先访问节点2，然后访问节点4，由于节点4没有相邻节点，我们返回节点2，然后访问节点5，发现它有一个相邻节点8，找到了目标节点，返回true。DFS会先搜索较深的分支，因此会先找到节点8。