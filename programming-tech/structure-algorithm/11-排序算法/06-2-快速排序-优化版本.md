## 由于快速排序的思路比较抽象，需要对分治和递归等概念有一定的理解，因此初学者可能会感到较为复杂。
1. 首先调用 quickSort 函数，传入要排序的数组 [52, 63, 14, 59, 68, 35, 8, 67, 45, 99]，以及左右边界 0 和 arr.length - 1。
2. 在 quickSort 函数内部，首先进行边界检查，发现左边界小于右边界，因此需要继续排序。

3. 接着调用 partition 函数，传入要排序的数组 [52, 63, 14, 59, 68, 35, 8, 67, 45, 99]，以及左右边界 0 和 9。

4. 在 partition 函数内部，首先将基准元素 99 保存下来，并将其移到数组的最右侧，即将数组变为 [52, 63, 14, 59, 68, 35, 8, 67, 45, 99]。

5. 接着定义一个 storeIndex 变量为 0，然后从左到右遍历数组。第一个数 52 小于基准元素 99，因此将其与 storeIndex 处的数 52 交换，将数组变为 [52, 63, 14, 59, 68, 35, 8, 67, 45, 99]。同时将 storeIndex 加 1，变为 1。

6. 接下来遍历到数 63，大于基准元素 99，不需要交换。继续遍历到数 14，小于基准元素 99，因此将其与 storeIndex 处的数 63 交换，将数组变为 [52, 14, 63, 59, 68, 35, 8, 67, 45, 99]。同时将 storeIndex 加 1，变为 2。

7. 继续遍历数组，直到遍历到数 45 时，将其与 storeIndex 处的数 68 交换，将数组变为 [52, 14, 63, 59, 45, 35, 8, 67, 68, 99]。同时将 storeIndex 加 1，变为 3。

8. 遍历结束后，将基准元素 99 移动到 storeIndex 处，即将数组变为 [52, 14, 63, 59, 45, 35, 8, 67, 68, 99]。

9. partition 函数返回 storeIndex，即 9，作为新的基准元素位置。

10. 回到 quickSort 函数内部，将数组分成左右两部分，分别为 [52, 14, 63, 59, 45, 35, 8, 67, 68]

11. 接着对左半部分 [52, 14, 63, 59, 45, 35, 8, 67, 68] 进行递归调用 quickSort 函数，传入左右边界 0 和 8。

12. 在新的 quickSort 函数内部，进行边界检查，发现左边界小于右边界，因此需要继续排序。

13. 接着调用 partition 函数，传入左半部分数组 [52, 14, 63, 59, 45, 35, 8, 67, 68]，以及左右边界 0 和 7。

14. 在 partition 函数内部，首先将基准元素 68 保存下来，并将其移到数组的最右侧，即将数组变为 [52, 14, 63, 59, 45, 35, 8, 67, 68]。

15. 接着定义一个 storeIndex 变量为 0，然后从左到右遍历数组。第一个数 52 小于基准元素 68，因此将其与 storeIndex 处的数 52 交换，将数组变为 [52, 14, 63, 59, 45, 35, 8, 67, 68]。同时将 storeIndex 加 1，变为 1。

16. 继续遍历数组，直到遍历到数 35 时，将其与 storeIndex 处的数 63 交换，将数组变为 [52, 14, 35, 59, 45, 63, 8, 67, 68]。同时将 storeIndex 加 1，变为 2。

17. 遍历结束后，将基准元素 68 移动到 storeIndex 处，即将数组变为 [52, 14, 35, 59, 45, 63, 8, 67, 68]。
18. partition 函数返回 storeIndex，即 8，作为新的基准元素位置。
19. 回到新的 quickSort 函数内部，将左半部分 [52, 14, 35, 59, 45, 63, 8, 67] 分成左右两部分，分别为 [52, 14, 35, 45, 8] 和 [59, 63, 67]。
20. 对左半部分 [52, 14, 35, 45, 8] 进行递归调用 quickSort 函数，传入左右边界 0 和 4。
21. 在新的 quickSort 函数内部，进行边界检查，发现左边界小于右边界，因此需要继续排序。

22. 接着调用 partition 函数，传入左半部分数组 [52, 14, 35, 45, 8]，以及左右边界 0 和 3。

23. 在 partition 函数内部，首先将基准元素 8 保存下来，并将其移到数组的最右侧，即将数组变为 [52, 14, 35, 45, 8]。

24. 接着定义一个 storeIndex 变量为 0，然后从左到右遍历数组。第一个数 52 大于基准元素 8，因此不需要交换位置。同时将 storeIndex 加 1，变为 1。

25. 继续遍历数组，直到遍历到数 45 时，将其与 storeIndex 处的数 14 交换，将数组变为 [52, 45, 35, 14, 8]。同时将 storeIndex 加 1，变为 2。

26. 遍历结束后，将基准元素 8 移动到 storeIndex 处，即将数组变为 [52, 45, 35, 14, 8]。

27. partition 函数返回 storeIndex，即 4，作为新的基准元素位置。
28. 回到新的 quickSort 函数内部，将左半部分 [52, 45, 35, 14, 8] 分成左右两部分，分别为 [45, 35, 14, 8] 和 [52]。
29. 对左半部分 [45, 35, 14, 8] 进行递归调用 quickSort 函数，传入左右边界 0 和 3。
30. 在新的 quickSort 函数内部，进行边界检查，发现左边界小于右边界，因此需要继续排序。
31. 接着调用 partition 函数，传入左半部分数组 [45, 35, 14, 8]，以及左右边界 0 和 2。
32. 在 partition 函数内部，首先将基准元素 8 保存下来，并将其移到数组的最右侧，即将数组变为 [45, 35, 14, 8]。
33. 接着定义一个 storeIndex 变量为 0，然后从左到右遍历数组。第一个数 45 大于基准元素 8，因此不需要交换位置。同时将 storeIndex 加 1，变为 1。
34. 继续遍历数组，直到遍历到数 14 时，将其与 storeIndex 处的数 35 交换，将数组变为 [45, 14, 35, 8]。同时将 storeIndex 加 1，变为 2。

35. 继续遍历数组，直到遍历到数 8 时，将其与 storeIndex 处的数 45 交换，将数组变为 [8, 14, 35, 45]。同时将 storeIndex 加 1，变为 3。
36. 遍历结束后，将基准元素 8 移动到 storeIndex 处，即将数组变为 [8, 14, 35, 45]。
37. partition 函数返回 storeIndex，即 0，作为新的基准元素位置。
38. 回到新的 quickSort 函数内部，将左半部分 [8, 14, 35, 45] 分成左右两部分，分别为 [] 和 [8, 14, 35, 45]。
39. 对左半部分 [] 进行递归调用 quickSort 函数，传入左右边界 0 和 -1。由于左边界大于右边界，因此不需要排序。
40. 对右半部分 [8, 14, 35, 45] 进行递归调用 quickSort 函数，传入左右边界 0 和 3。
41. 在新的 quickSort 函数内部，进行边界检查，发现左边界小于右边界，因此需要继续排序。
42. 接着调用 partition 函数，传入左半部分数组 [8, 14, 35, 45]，以及左右边界 0 和 2。
43. 在 partition 函数内部，首先将基准元素 14 保存下来，并将其移到数组的最右侧，即将数组变为 [8, 35, 45, 14]。
44. 接着定义一个 storeIndex 变量为 0，然后从左到右遍历数组。第一个数 8 小于基准元素 14，因此将其与 storeIndex 处的数 35 交换，将数组变为 [35, 8, 45, 14]。同时将 storeIndex 加 1，变为 1。
45. 继续遍历数组，直到遍历到数 45 时，将其与 storeIndex 处的数 8 交换，将数组变为 [35, 8, 45, 14]。同时将 storeIndex 加 1，变为 2。
46. 遍历结束后，将基准元素 14 移动到 storeIndex 处，即将数组变为 [35, 8, 14, 45]。
47. partition 函数返回 storeIndex，即 2，作为新的基准元素位置。
48. 回到新的 quickSort 函数内部，将左半部分 `[35, 8, 14]

49. 将左半部分 [35, 8, 14] 分成左右两部分，分别为 [8] 和 [35, 14]。
50. 对左半部分 [8] 进行递归调用 quickSort 函数，传入左右边界 0 和 0。由于只有一个元素，不需要排序。
51. 对右半部分 [35, 14] 进行递归调用 quickSort 函数，传入左右边界 0 和 1。
52. 在新的 quickSort 函数内部，进行边界检查，发现左边界小于右边界，因此需要继续排序。
53. 接着调用 partition 函数，传入左半部分数组 [35, 14]，以及左右边界 0 和 0。
54. 在 partition 函数内部，首先将基准元素 35 保存下来，并将其移到数组的最右侧，即将数组变为 [14, 35]。
55. 接着定义一个 storeIndex 变量为 0，然后从左到右遍历数组。第一个数 14 小于基准元素 35，因此将其与 storeIndex 处的数 14 交换，将数组变为 [14, 35]。同时将 storeIndex 加 1，变为 1。
56. 遍历结束后，将基准元素 35 移动到 storeIndex 处，即将数组变为 [14, 35]。
57. partition 函数返回 storeIndex，即 1，作为新的基准元素位置。
58. 回到新的 quickSort 函数内部，将左半部分 [14] 分成左右两部分，分别为 [] 和 [14]。
59. 对左半部分 [] 进行递归调用 quickSort 函数，传入左右边界 0 和 -1。由于左边界大于右边界，因此不需要排序。
60. 对右半部分 [14] 进行递归调用 quickSort 函数，传入左右边界 0 和 0。由于只有一个元素，不需要排序。
61. 排序结束，最终数组变为 [8, 14, 35, 45, 52, 59, 63, 67, 68, 99]。