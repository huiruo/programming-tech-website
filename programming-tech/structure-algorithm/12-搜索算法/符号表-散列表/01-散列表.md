---
title: 散列表
sidebar_position: 1
---

## 前言
先来比较一下数组和链表的优缺点：
数组：寻址容易，但插入和删除元素比较麻烦； 链表：插入和删除元素容易，但寻址比较麻烦。

```
有没有一种数据结构是既能结合这两种的优点同时也能避免这两种数据结构所带来的缺点呢？
哈希表就是这样的数据结构：
哈希表的底层实际上是基于数组来存储的，当插入键值对时，并不是直接插入该数组中，而是通过对键进行Hash运算得到Hash值，
然后和数组容量取模，得到在数组中的位置后再插入。

取值时，先对指定的键求Hash值，再和容量取模得到底层数组中对应的位置，
如果指定的键值与存贮的键相匹配，则返回该键值对，如果不匹配，则表示哈希表中没有对应的键值对。这样做的好处是在查找、插入、删除等操作
在理想情况下做到O(1)，极端情况（哈希值冲突到同一个位置）是O(n)。
```

```
哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，
它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
```

## O(1)
```
哈希表通过哈希函数将键值转化为哈希值，再通过哈希值就可以找到存储的内容，从而使键值起到类似于数组下标的作用。
这样哈希表通过O(1)的时间复杂度就能找到存储元素。
```

## For循环时间复杂度
```
O（n）。只有一个for循环，循环了n次。
```

## 哈希基本概念
```
1.哈希化:将大数字转化为数组下标范围内的过程
2.哈希函数:所有的哈希函数都具有的基本性质：如果根据相同的哈希函数得到的散列值是不同的，这两个散列值的原始输入也是不同
3.哈希表:数据经过哈希算法后得到的集合
哈希表就是一种映射关系的表，它是通过hash算法得来的，通常而言，是一个固定长度的数组。
```

## 哈希函数
根据设定的哈希函数H（key）和处理冲突方法将一组关键字映象到一个有限的地址区间上的算法。
```
由于哈希表的长度是有限的，而查找的key值是无限的，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。
所以为了构造一个好的哈希函数，我们希望hash函数作用在不同的key时，所得到的value能够均匀的分布在hash表中，即能尽可能少的减少哈希冲突。
常用的哈希算法有:MD4,MD5,SHA-1。

解决哈希冲突的几种方法：
1.链地址法。每个数组单元中储存的不再是单个数据，而是一个链条，用的更多，java的 HashMap，它解决hash冲突使用就是链地址法。
2.开放地址法。主要思想是发生冲突时，直接去寻找下一个空的地址，只要底层的表足够大，就总能找到空的地址。这个寻找下一个地址的行为，叫做探测。主要有:线性试探法、二次探测。
公共溢出区（不常用）。将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表(注意：在这个方法里面是把元素分开两个表来存储)。
```