---
title: 总结
sidebar_position: 3
---

## window.onerror
该方法可以捕获所有未被捕获的 JavaScript 异常，并将其作为参数传递给处理程序函数。

要在项目中使用 window.onerror 方法，您需要在全局范围内定义该方法。
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>My Website</title>
  <script>
    window.onerror = function(message, url, line, column, error) {
      console.log('发生了异常：' + message);
      console.log('在文件 ' + url + ' 的第 ' + line + ' 行，第 ' + column + ' 列');
      console.log('错误对象：', error);
    };
  </script>
</head>
<body>
  <!-- 页面内容 -->
  <script src="main.js"></script>
</body>
</html>
```

### fn组件实现的错误边界
```js
import React, { useState, useEffect } from 'react';

function ErrorBoundary({ children }) {
  const [hasError, setHasError] = useState(false);

  useEffect(() => {
    const handleErrors = (error, info) => {
      // 在这里处理异常
      console.log('发生了异常：' + error);
      console.log('堆栈信息：' + info.componentStack);
      setHasError(true);
    };
    window.addEventListener('error', handleErrors);
    return () => window.removeEventListener('error', handleErrors);
  }, []);

  if (hasError) {
    // 在这里呈现备用 UI
    return <h1>发生了错误</h1>;
  }
  return children;
}

export default ErrorBoundary;
```

使用：
```js
import React from 'react';
import ErrorBoundary from './ErrorBoundary';

function MyComponent() {
  // 在这里定义组件
}

export default function App() {
  return (
    <ErrorBoundary>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

### 在类组件中，react17
使用 static getDerivedStateFromError() 和 componentDidCatch() 方法来代替 componentDidCatch() 方法来处理错误:
```js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error: error };
  }

  componentDidCatch(error, errorInfo) {
    console.error(error, errorInfo);
    this.setState({ errorInfo: errorInfo });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Oops! Something went wrong.</h1>
          <p>{this.state.error && this.state.error.toString()}</p>
          <p>{this.state.errorInfo.componentStack}</p>
        </div>
      );
    }

    return this.props.children;
  }
}

class App extends React.Component {
  render() {
    return (
      <div>
        <ErrorBoundary>
          <App />
        </ErrorBoundary>
      </div>
    );
  }
}
```

## webpack bundle 大小优化
[构建包大小优化](../build-webpack/构建包大小优化)

* 异步懒加载加载路由
一.解决首屏问题我们用异步懒加载加载路由，这样我们大开一个页面的时候只打开公共部分和这个页面独立的部分。

其次将大的包用异步分包的方式使用异步加载下来。这样首屏的时间大大降低，SSR这里的优势只有在js渲染HTML的这个时间，但是这个时间大多数情况下根本不是问题。

* 使用 Tree Shaking,Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码（没用到的代码）。它依赖静态的 ES6 模块化语法，例如通过 import 和 export 导入导出。

* 压缩代码:UglifyJS

## 代码层面
* 提取公共代码
* 分割代码为更小的块而不是大块代码,提升编译速度

## ssr 服务端渲染

## 静态资源缓存
参考：[浏览器缓存](../http-浏览器缓存/浏览器缓存)

## CDN
参考：[CDN](./CDN-内容分发网络)

## 心理上：比如骨架屏，loading动画

## 优化http请求数
为什么资源并发比较多的网站，用户体验很差，如页面初始化请求大量静态资源。
- `我们可以通过将资源分布在不用域名，比如说CDN`，来解决这个问题。

但是其实浏览器对所有域名的总连接数也有限制：
- 除了资源分布在不同域名上之外，`可以将资源合并`。总所周知的雪碧图、webpack资源打包。

- 也可以使用http2
```
HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求，目前部分主流网站开始部分支持http2.0。
```
![](../assets/img-optimize/02-查看http版本号.png)

前端性能之Chrome的Waterfall
- 浅灰：查询中
- 深灰：停滞，代理转发，请求发送
- 橙色：初始连接
- 绿色：等待中
- 蓝色：内容下载

### 一个tcp连接同时可以发送几个http请求？
浏览器最大连接数，即浏览器支持对同一个域名同时建立多少个http连接。
从HTTP1.1考虑的话，它其实等同于浏览器对同一个域名支持同时建立多少个tcp连接数，毕竟HTTP1.1版本一个tcp连接只能同时处理一个http请求。

HTTP1.1及以下的版本，一个tcp连接不能并发处理多个http请求。即，如果一个http请求未结束，该tcp连接无法发起下一个http请求。

为什么我的浏览器可以同时请求了多个相同服务器的资源？

浏览器是可以针对同一个资源地址建立多个tcp连接的。验证方式就是关掉浏览器（强行断开持久化连接）再打开该页面，查看Network 的waterfall，看看是否有2个以上的同域资源建立了Initial connection，如下图：
![](../assets/img-optimize/01-查看http持久链接.png)
```
Firefox 2:  2
Firefox 3+: 6
Opera 9.26: 4
Opera 12:   6
Safari 3:   4
Safari 5:   6
IE 7:       2
IE 8:       6
IE 10:      8
Chrome:     6
```

### 升级http2
http/2最大的特点是使用多路复用，对同一个域的服务器只建立一次TCP连接，加载多个资源，使用二进制帧传输，同时会对http头部进行压缩。使用http2会比http/1.1更加地高效

多路复用

多路复用的意义在于可以用同一个连接传输多个资源，进而使得以前在http 1.1所做一些优化就没有必要了，如：
a）使用雪碧图技术，把多张小图合成一张大图，减少请求数；
b）合并JS和CSS，减少请求数。

```
http 1.1时代，由于需要建立多个TCP连接，服务器需要更多的线程来处理请求，同样地，浏览器也需要，所以浏览器会限制同一个域的同时请求数，Chrome是限制6个，总连接数是17个。
可以实际对比一下，http 1.1会让资源排队加载

如果使用http2
你会发现这些资源都是同时加载的，后面加载的资源不需要进行排队。也就是说理论上带宽有多大，就能传多快。
```

## 使用requestAnimationFrame 实现动画
requestAnimationFrame使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。

[html-css-requestAnimationFrame](../html-css/requestAnimationFrame/requestAnimationFrame-是宏任务吗)


## 大型应用为什么会慢?
网页性能问题大都出现在DOM节点频繁操作上

在构建复杂的大型应用的时候，各种页面之前的相互操作和更新很有可能会引起页面的回流或重绘，而频繁操作这些dom其实是非常消耗性能的:一个节点上的属性，可以看到一个节点上的属性是非常多的，在复杂应用中，操作这些属性的时候可能一不小心就会引起节点大量的更新

## 为什么JS长时间执行会影响交互响应、动画？
浏览器机制：
JavaScript 引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待。

因为JavaScript在浏览器的主线程上运行，恰好与样式计算、布局以及许多情况下的绘制一起运行。

如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，就会阻塞这些其他工作，会导致页面响应度变差，可能导致掉帧。用户可能会感觉到卡顿。

我们都知道浏览器渲染引擎是单线程的，在 React15.x 及之前版本，从 setState 开始到渲染完成整个过程是不受控制且连续不中断完成的，由于该过程将会占用整个线程，则其他任务都会被阻塞，如样式计算、界面布局以及许多情况下的绘制等。如果需要渲染的是一个很大、层级很深的组件，这可能就会使用户感觉明显卡顿，比如更新一个组件需要1毫秒，如果有200个组件要更新，那就需要200毫秒，在这200毫秒的更新过程中，浏览器唯一的主线程在专心运行更新操作，无暇去做其他任何事情。想象一下，在这200毫秒内，用户往一个input元素中输入点什么，敲击键盘也不会立即获得响应，虽然渲染输入按键结果是浏览器主线程的工作，但是浏览器主线程被React占用，抽不出空，最后的结果就是用户敲了按键看不到反应，等React更新过程结束之后，咔咔咔那些按键一下子出现在input元素里了，这个版本的调和器可以称为栈调和器（Stack Reconciler）。Stack Reconciler 的主要缺陷就是不能暂停渲染任务，也不能切分任务，更无法有效平衡组件更新渲染与动画相关任务间的执行顺序（即不能划分任务优先级），这样就很有可能导致重要任务卡顿，动画掉帧等问题。
