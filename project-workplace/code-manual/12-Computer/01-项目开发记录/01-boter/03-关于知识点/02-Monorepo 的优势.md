## 前言
```
在 Monorepo 项目中你可以同时管理多个逻辑共存的应用程序，比如桌面应用程序和 Web 应用程序，甚至 Ios 应用也可以保存在 Monorepo 中，只要你愿意的话。


通常在实现一些大型项目架构时，我们会尽可能的拆分一些大型功能独立到一些包之中通过在主应用程序之中通过入口点来加载它。


但是随之而来问题就产生了，如果按照传统方式来拆分这些包每个独立的应用包之间都应该存在一份自己的工作流配置。换而言之，每当我们希望独立出一个新包时需要重复创建配置环境以及配置新环境。

同样在构建应用时，如果某些包内部出现依赖我们不得不的在修改被依赖的包发布之前，依次构建相关依赖包版本并且重新发布。在存在多个项目依赖之间互相依赖时，这无疑是一种灾难。


为了解决上述的问题，Google 提出了 Monorepo 的理念，使用一个项目代码库来管理多个项目包的开发、构建与发布。
```
## 优势
基于 Monorepo 的出现，我们可以更多的业务层面的分离而不需要分离时随之而来冗余繁琐的项目依赖问题。我们可以基于一个仓库下共享多个应用程序之间的配置和依赖。

同时我们可以利用业内成熟的工具来辅助管理我们关于多依赖包之间的版本发布。
```
抽离多个重复配置文件: 将多个应用程序抽离到一个代码仓库中管理，无疑针对于繁琐且重复的配置文件与环境，我们可以仅仅贡献一份配置文件，然后利用该配置来构建所有的包。 

轻松的拉取所有最新的代码: 此时由于 Monorepo 的解决方案，解决了多个远程仓库的问题。在拉去代码时，通常我们仅仅需要一个简单的拉取请求即会拉取到所有最新的所有代码内容。 

更加简单的 NPM 发布: 上边我们谈到过，基于多个依赖包之间版本管理的问题。基于 Monorepo 的解决方案我们可以利用一些比如 Lerna、Yarn Workspaces  等工具更加自动化的处理依赖包之间的构建和发布。 

更容易的依赖管理: 我们可以提升多个项目中相同的依赖在项目的根依赖中进行管理，这意味这这会大大的缩小项目依赖在硬盘上占据的空间。 

更好的逻辑复用方案: 基于 Monorepo 的解决方案，我们在独立出不同应用之间逻辑的同时可以基于包之间可以更加清晰的在模块之间复用其他模块。量，尽管可以使用解决重文件问题），性能也会降低吉特 LFS）。
```

